# 算法

###  [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

**题解**：

待补充

**代码**：

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null;ListNode tail = null;
        int carry = 0;
        while(l1 != null || l2 != null){
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if(head == null){
                head = tail = new ListNode(sum%10); 
            } else{
                tail.next = new ListNode(sum%10); 
                tail = tail.next;
            }
            carry = sum/10;
            if(l1 != null ){
                l1 = l1.next;
            }
            if(l2 != null){
                l2 = l2.next;
            }
        }
        if(carry > 0){
            tail.next = new ListNode(carry); 
        }
        return head;
        
    }
}
```




### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

**题解**：

（取出的字符放到HashSet中）使用两个指针，从左往右移动，统计左指针在每个字符上时，左指针到右指针的长度，遇到HashSet中有右指针所指的值时，左指针右移一位继续统计；取出每次统计的最大值，即是**最长子串** 的长度。

**代码：**

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个字符是否出现过
        Set<Character> occ = new HashSet<Character>();
        int n = s.length();
        int ans = 0;
        int rk = -1;
        
            // 如果重复元素 移除重复元素，左指针右移一位；
        for (int i = 0; i < n ; i++) {
            if (i > 0) {
                occ.remove(s.charAt(i -1));
            }

            // 添加一个元素，右指针右移一位
            while(rk + 1 < n){
                if (occ.contains(s.charAt(rk + 1))) {
                    // 遇到有重复字符，直接跳出当前循环，左指针右移一位
                    break;
                }
                 occ.add(s.charAt(rk + 1));
                rk++;
            }
            
              // 统计无重复长度 ans 
            ans = Math.max(ans,rk - i + 1);
        }
           
        return ans;

    }
}
```

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

**题解：**

1.暴力解法：即从左到右依次截取字符串，判断是否是的回文字串，然后从字串中取最长的

2.动态规划：用`boolean dp[l][r]` 表示从i到j是否是回文，如果`boolean dp[l][r] = true`,又要判断`dp[l + 1][r - 1]`是否是回文，只需要判断 （l+ 1）和(r - 1)上的字符是否相当。

初始状态：l = r ,`dp[l][r] = true`;状态转移方程，`dp[l][r] = true`且 （l+ 1）和(r - 1)上的字符相同，即：`dp[l + 1][r - 1] = true`。

3.其他解法：以后再说



```java
class Solution {
    public static String longestPalindrome(String s) {
        if(s.length() < 2){
            return s;
        }
        int length = s.length();
        int maxLenth = 1;
        int start = 0;
        boolean[][] dp = new boolean[length][length];
        char[] chars = s.toCharArray();
        for(int right = 1;right < length;right++){
            for(int left = 0;left < right;left++){
                if (left == right) {
                    dp[left][right] = true;
                } else {
                    if(chars[left] != chars[right]){
                        dp[left][right] = false;
                    } else{
                        if(right - left < 3){
                            dp[left][right] = true;
                        } else{
                            dp[left][right] = dp[left + 1][right - 1] ;
                        }
                    }
                }
                if(dp[left][right] && right - left + 1 > maxLenth){
                    maxLenth = right - left + 1;
                    start = left;
                }
            }
        }

        return s.substring(start,start+ maxLenth);
    }

}
```

### [6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)

**题解**：

1.按行排序：从左往右迭代字符串，把分属于同一行的字符放到同一个StringBuilder 中，行方向会在第一行和最后一行会发生变化，然后去把所有收集到的字串拼起来。

```java
class Solution {
    public  String convert(String s, int numRows) {
          if (numRows == 1) {
            return s;
        }
        // 先创建一个字符串StringBuilder 的list用来 存放不同行的字符
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for (int rowNum = 0; rowNum < Math.min(numRows,s.length()); rowNum++) {
            rows.add(new StringBuilder());
        }
        // 根据字符在首行还是末行来变换 行方向 把得到的每一行字符串放到一个 StringBuilder中
        int row = 0;
        int step = 0;
        for (char c : s.toCharArray()) {
            rows.get(row).append(c);
            // 第一行 往后行要增加 
            if (row == 0) {
                step = 1;
            // 最后一行，行要减小，往回走
            } else if (row == numRows - 1) {
                step = -1;
            }
            row += step;
        }
        // 遍历StringBuilder的list拼接字符串，然后返回
        StringBuilder ans = new StringBuilder();
        for (StringBuilder stringBuilder : rows) {
            ans.append(stringBuilder);
        }
        return ans.toString();

    }
}
```

**2.按行访问**：推导每一行的字符在原字符串中的位置公式，然后去遍历收集字符串。

代码：以后再写。

### [7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

**题解：**

1.用

```java
 remainder = x % 10;取余提取个位

 x /= 10;移除掉刚刚提取的个位，数字向右移一位

 // 这里乘 10，下次进入要判断是否溢出

 rev = rev * 10 + remainder;乘10+刚刚得到的余数
```

来表示反转后的整数，同时，rev 乘10了，每次判断乘10前的rev反转整数有没有溢出。

代码

```java
class Solution {
    public int reverse(int x) {
        int rev = 0;
        // 用余数 提取低位
        int remainder = 0;
        while(x != 0){
            // 判断乘 10 之前的rev是否越界
            if(rev < Integer.MIN_VALUE / 10 ||rev > Integer.MAX_VALUE / 10){
                return 0;
            }
            remainder = x % 10;
            x /= 10;
            // 这里乘 10，下次进入要判断是否溢出
            rev = rev * 10 + remainder;
        }
        return rev;
    }
}
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**题解**：

用左右left、right两个指针向内移动，同时获取它们对应位置上的值，取这两个值的最小值，面积为（right - left）*最小值，记录下来，取所有这个过程的最大值，即为容器最大值。

代码：

```java
class Solution {
    public int maxArea(int[] height) {
        if(height.length < 2){
            return 0;
        }
        int left = 0;
        int rigth = height.length -1;
        int ans =0;
        while(left < rigth){
            ans = Math.max((rigth - left)*Math.min(height[left],height[rigth]),ans);
            // 如果左边值如果小，说明可以右移，看有没有更大的值
            if(height[left] <= height[rigth]){
                left++;
            }else{
            // 反之如是    
                rigth--;
            }
        }
        return ans;
    }
}
```

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

**题解：**

用**hash表+双向链表**来实现，hash表实现get和put O(1)的时间复杂度，双向链表来实现淘汰最久未使用的键值对（put的时候判断容量是否超出设定容量，然后超出则删除链表最后的元素，对应hash表中的元素也删除，put的元素放在链表最前面），get之后把元素从链表尾移动的链表头位置。使用一个伪头和伪尾，标记界限，这样添加和删除元素的时候就不用检查相邻元素是否存在。

```java
public class LRUCache {
    class DLinkedNode{
      int key;
      int value;
      DLinkedNode prev;
      DLinkedNode next;
      public DLinkedNode(){};
      public DLinkedNode(int key,int value){
        this.key = key;
        this.value = value;
      };
    } 

  	private Map<Integer,DLinkedNode> cache = new HashMap<Integer,DLinkedNode>();
  	private int capacity;
  	private int size;
  	private DLinkedNode head,tail;
  	
    public LRUCache(int capacity) {
			this.capacity = capacity;
      this.size = 0;
      // 使用伪头部和伪尾部节点
      this.head = new DLinkedNode();
      this.tail = new DLinkedNode();
      head.next = tail;
      tail.prev = head;
    }
    
    public int get(int key) {
			DLinkedNode node = cache.get(key);
      if(node == null){
        return -1;
      }
      // 如果存在，则移动到头节点
      moveToHead(node);
      return node.value;
    }
  
   public void put(int key, int value) {
     DLinkedNode node = cache.get(key);
     if(node == null){
       // 如果节点不存在，创建一个新的节点
        DLinkedNode newNode = new DLinkedNode(key,value); 
       	cache.put(key,newNode);
       // 放到链表头节点位置
       addToHead(newNode);
       size++;
       if(size > capacity){
        // 移除链表尾节点值
          DLinkedNode tailNode = removeTail(); 
         	cache.remove(tailNode.key);
        	size--;
       }
     }else{
       // 如果节点存在，更新值
       node.value = value;
       // 移动到头节点位置
       moveToHead(node);
     }

    }
  
  	private void addToHead(DLinkedNode node){
      node.next = head.next;
      head.next.prev = node;
      head.next = node;
      node.prev = head;
    }
  	private void moveToHead(DLinkedNode node){
      removeNode(node);
      addToHead(node);
    }
    private DLinkedNode removeTail(){
      DLinkedNode removeTail = tail.prev;
      removeNode(removeTail);
     	return removeTail; 
    }
    private void removeNode(DLinkedNode node){
			node.next.prev = node.prev;
      node.prev.next = node.next;
    }	
}

```

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**题解：**

1.用快速排序，Partition过程的那个值，如果下标q等于k对应的下标直接返回结果，如果Partition返回的值的下标q小于k对应的下标，取q右半区间继续Partition,否则取左半区间继续Partition，直到Partition返回下标q等于k对应的下标。平均时间复杂度*O*(*n*log*n*)。

2.用大根堆，弹出k-1次，再弹出（即第k次弹出的）的值就是第k大的元素。（大根堆要自己实现）。时间复杂度：*O*(*n*log*n*)。

```java
// 用快排实现
class Solution {
  	Random random = new Random();
    public int findKthLargest(int[] nums, int k) {
				return quickSelect(nums,0,nums.length - 1,nums.length - k);
    }
 		// 快排选择
  	public int quickSelect(int[] nums,int left,int right,int index){
      int q = radomPartition(nums,left,right);
      if(q == index){
        return nums[q];
      } else{
        return q < index ? quickSelect(nums,q + 1,right,index) : quickSelect(nums,left,q - 1,index);
      }
    }
  	// 随机快排 Partition
  	public int radomPartition(int[] nums,int left,int right){
        int r = random.nextInt(right - left + 1) + left;
      	swap(nums,r,right);
      	return partition(nums,left,right);
    }
    // Partition
  	public int partition(int[] nums,int left,int right){
      int less = left - 1;
      int index = left;
      while(index < right){
        if(nums[index] <= nums[right]){
          swap(nums,index,++less);
        }
        index++;
      }
       swap(nums,right,++less);
      return less;
    }
  	public void swap(int[] nums,int i,int j){
      int temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
    }
}
```

```java
// 大根堆实现方法
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int size = nums.length;
      	// 最后一个父节点(size - 1) / 2，这里直接取size / 2
        for (int i = size / 2; i >= 0  ; i--) {
            heapify(nums, i, size);
        }

        for (int i = 0; i < k - 1; i++) {
          	// 堆顶元素移到最后，size--，然后调整堆
            swap(nums,0, --size);
            heapify(nums, 0, size);
        }
        return nums[0];
    }

    // 往下移动
    public void heapify(int[] arr, int index, int heapSize){
        int left = 2 * index + 1;
        while (left < heapSize){
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            swap(arr,largest,index);
            if (index == largest) {
                break;
            }
            index = largest;
            left =  2 * index + 1;
        }
    }

    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

**题解：**

把链表节点按照k个一组分组，使用一个head指针，一次移动k步，对于每次分组，先判断是否大于等于k，否则则不反转。对于链表头之前没有pre节点，构造一个pre。

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode before = new ListNode(0);
        before.next = head;
        ListNode pre = before;

        while (head != null) {
            ListNode tail = pre;
            // 指针移动k步
            for (int i = 0; i < k; i++) {
                tail = tail.next;
                if (tail == null) {
                    return before.next;
                }
            }
            // 记录下次 分组的头节点
            ListNode nex = tail.next;
            // 分组反转链表
            ListNode[]  reverse = reverseLinked(head,tail);
            head = reverse[0];
            tail = reverse[1];
            // 重连链表
            tail.next = nex;
            pre.next = head;
            // 下次循环进入赋值
            pre = tail;
            head = tail.next;

        }
        return before.next;
    }
    private ListNode[] reverseLinked(ListNode head,ListNode tail){
        ListNode prev = tail.next;
        ListNode cur = head;

        while(prev != tail){
            // 下一个进入循环的，将是当前节点的prev节点
            ListNode nex = cur.next;
            // 当前节点连接下一个节点
            cur.next = prev;
            // 为下一次循环赋值
            prev = cur;
            cur = nex;

        }
        return new ListNode[] {tail,head};
    }
}
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

**题解：**

排序+双指针：三元组 (*a*,*b*,*c*)满`a≤b≤c`,不会有(*a*,*c*,*b*)这样的重复枚举，所以需要先排序。需要三重循环，而且不重复循环，所以第二重在第一重后面，第三重从数组尾端和第二重相向遍历。这就是双指针了。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
			// 先排序
      Arrays.sort(nums);
      int n = nums.length ;
      List<List<Integer>> ans = new ArrayList<>();
      for(int first = 0;first < n;first++){
        int third = n - 1;
        int target = -nums[first];
        // 如果当前元素和上一个一样，跳过
        if(first > 0 && nums[first] == nums[first - 1]) continue;
        for(int second = first + 1 ; second < n;second++){
          // 如果当前元素和上一个一样，跳过
          if(second > first + 1 &&  nums[second] == nums[second - 1]) continue;
          while(second < third && nums[second] + nums[third] > target){
            third--;
          }
          // 遍历到这里说明遍历完了，可以推出循环了
          if(second == third){
              break;
          }

          if(nums[second] + nums[third] == target){
            List<Integer> list = new ArrayList<>();
            list.add(nums[first]);
            list.add(nums[second]);
            list.add(nums[third]);
            ans.add(list);
          }
        }
      }
      return ans;
    }
}
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**题解：**

1.动态规划，从第一个数开始累加，如果当前数前面最大的子区间小于0，则舍弃前面的子区间，从当前数开始重新累加。后面重复同样的操作。同时，每一步取遍历到以当前数结尾的子区间和的最大值。

```java
class Solution {
    public int maxSubArray(int[] nums) {
       int pre =0,sum = nums[0];
       for(int num : nums){
          // pre其实就是num前面的子数组的累加和
           pre = Math.max(pre + num,num);
           sum = Math.max(pre,sum);
       }
       return sum;
    }
}
```

2.分治：待学习。

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

**题解：**

1.递归：没啥好说的，节点值小的连在前面，链表有空就不需要合并，直接返回非空的链表。

2.迭代：注意需要一个伪头节点用来返回合并好的链表用，还有一个prev指针，反复调整它的next指针，直到L1或L2指向了空。

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
       // 递归写法
       if(list1 == null){
           return list2;
       } else if(list2 == null){
           return list1;
       } else if(list1.val <= list2.val){
           list1.next = mergeTwoLists(list1.next,list2);
           return list1;
       } else{
           list2.next = mergeTwoLists(list1,list2.next);
           return list2;
       }
    }
}
```

```java
class Solution {
	// 迭代写法
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 伪头节点
        ListNode preHead = new ListNode(-1);
        ListNode prev = preHead;

        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                prev.next = list1;
                list1 = list1.next;
            } else{
                 prev.next = list2;
                list2 = list2.next;
            }
            prev = prev.next;

        }
         prev.next = list1 == null ? list2 : list1;

        return preHead.next;
    }
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

**题解：**

1.用HashSet，把链表的节点一个个的放到HashSet中，如果add返回false说明HashSet中已经放过这个节点，是环形链表。时间复杂度`O(n)`，空间复杂度`O(n)`

2.用双指针，快慢指针，慢指针head开始，快指针head.next开始，当两个指针撞上了，说明是环形链表。时间复杂度：*O*(*N*)，空间复杂度`O(1)`

```java
public class Solution {
  	// HashSet解法
    public boolean hasCycle(ListNode head) {
        Set<ListNode> set = new HashSet<>();
        while(head != null){
            if(!set.add(head)){
                return true;
            }
            head = head.next;
        }
        return false;
    }
  
}
```

```java
public class Solution {
  	// 快慢指针解法
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != slow){
            if(fast == null || fast.next == null){
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

**题解：**

1.因为卖出时间肯定是在买入时间后，所以计算出价格的最小值，然后 当前价格-历史最低价> 历史最高利润 则当前差价为最高利润，所有利润中取最高即是最大利润，一层for循环即可。时间复杂度：*O*(*n*)。

2.暴力解法，两层for循环，内层为卖出价，外层为买入价，统计处最高利润即可。时间复杂度：*O*(n^2^)。

```java
class Solution {
  	// 解法1
    public int maxProfit(int[] prices) {
        int maxProfit = 0;
        int minPrice = Integer.MAX_VALUE;
        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(price - minPrice,maxProfit);
        }
        return maxProfit;
    }
}
```

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

**题解：**

1.用HashSet，把链表值放到HashSet中，add方法返回false，即表面在那个元素位置相交。

2.双指针法，指针a、b分别遍历两个A、B链表，a从headA 开始指向链表尾后，再指向headB，继续遍历，指针b同理。这样两个指针走过的a+b+c = c + b + a,

会在这个路程的最后相遇，即为相交点。

```java
public class Solution {
    // 双指针法
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null){
            return null;
        }
        ListNode pA = headA;
        ListNode pB = headB;
        while(pA != pB){
           pA = pA == null ? headB : pA.next;
           pB = pB == null ? headA : pB.next; 
        }
        return pA;
    }
}
```

### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

**题解：**

1.双指针，因为俩数组已经排序，直接遍历比较大小，放到辅助数组中，然后再放回nums1中。时间复杂度：O(m+n)。空间复杂度：O(m+n)。

2.逆向双指针，因为数组是有序的，从后往前遍历，muns1长度m+n，从右往左把元素放到nums1中时，恰好元素不会被覆盖。每个数组的指针移动到-1时说明元素已经被移动完，要只移动另外一个数组的元素了，直到另外一个数组指针也到-1，合并完成。

```java
class Solution {
    // 逆向双指针法
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m -1;
        int p2 = n -1;
        int tail = m + n -1;
        while(p1 >= 0 || p2 >= 0){
            if(p1 == -1){
                nums1[tail--] = nums2[p2--];
            } else if(p2 == -1){
                nums1[tail--] = nums1[p1--];
            } else if(nums1[p1] > nums2[p2]  ){
                nums1[tail--] = nums1[p1--];
            } else{
                nums1[tail--] = nums2[p2--];
            }
        }
    }
}
```

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

**题解：**

1.利用栈的先进后出原理，顺序遍历字符，如果是左半的字符，则把字符放到栈中，否则，根据对应的右半字符判断弹出的字符是否是对应的左半字符，如果不是，返回false。

```java
class Solution {
    public boolean isValid(String s) {
       if (s.length() % 2 == 1) {
            return false;
        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '{' || c == '['){
                stack.push(c);
            } else if (stack.isEmpty()
                    || c == ')' && stack.pop() != '('
                    || c == ']' && stack.pop() != '['
                    || c == '}' && stack.pop() != '{') {
                return false;
            }
        }
        return stack.isEmpty();
    }
}
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

**题解：**：

1.二分法，要先确定是在前一半有序数组上，还是后一半的有序数组上，然后再去二分。时间复杂度：*O*(log*n*)。

```java
class Solution {
    public int search(int[] nums, int target) {
         if (nums.length < 2) {
            return nums.length == 1 ? nums[0] == target ? 0 : -1 : -1;
        }
        int left = 0;
        int right = nums.length -1;
        int first = nums[0];

        while (left <= right) {
            int mid = left + ((right -left) >> 1);
            if (target == nums[mid]) {
                return mid;
            }
            // 通过比交Mid 和 第一个节点比大小确定是在前半有序数组上，还是后一半有序数组上
            if ( first <= nums[mid]) {
                if (first <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[nums.length -1]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }

            }
        }
        return -1;
    }
}
```

### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

**题解：**

就是二叉树的层序遍历，然后利用双端队列，把遍历出的元素按照addLast还是addFirst来实现不同的遍历方向。每一层的双端队列元素即是每一层的答案。

```java
class Solution {
        public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<List<Integer>>();
        if (root == null) {
            return ans;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        boolean isLeft = true;
        while (!queue.isEmpty()){
            LinkedList<Integer> levelAns = new LinkedList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue.poll();
                if (isLeft) {
                    levelAns.addLast(cur.val);
                } else {
                    levelAns.addFirst(cur.val);
                }

                if (cur.left != null) {
                    queue.add(cur.left);
                }
                if (cur.right != null) {
                    queue.add(cur.right);
                }
            }
            ans.add(levelAns);
            isLeft = !isLeft;
        }
        return ans;
    }
}
```

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

**题解：**

用递归实现：分两种情况，1.root == null 或者 root == q 或者 root == p，2.p、q分别在公共祖先的两个左右子树上。第一种情况直接返回，第二种情况继续递归，分别找到p、q节点，如果在左支上找到，则返回左该节点；如果在右支上找到，则返回右该节点；递归退回最内层的左、右都不为空时，就是最近的公共祖先节点，返回。

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果root == null 或者 root == q 或者 root == p时，直接返回
        if(root == null || root == p || root == q){
            return root;
        }
        // 分别查找左右子树上是否有该节点，有的话直接返回对应节点。
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        // 返回对应子树上含有的p、q
        if(left == null){
            return right;
        }
        if(right == null){
            return left;
        }
        // 如果左右子树上都找到了，说明这一层的root是它们最近的公共祖先，返回
        return root;

    }
}
```
### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

**题解：**

1.用递归实现，先根节点-> 右子树 - > 左子树，和先序遍历（根节点 - > 左子树-> 右子树）相反。

```java
class Solution {
    private List<Integer> ans = new ArrayList<Integer>(); 
    public List<Integer> rightSideView(TreeNode root) {
        dfs(root,0);
        return ans;
    }

    private void dfs(TreeNode root,int depth){
        if(root == null){
            return;
        }
    // 当返回的集合元素个数和二叉树深度相同时，说明是当前层还没有没有一个元素放入集合中，而且是右子树先递归，所以这就是答案
        if(depth == ans.size()){
            ans.add(root.val);
        }
        dfs(root.right,++depth);
        dfs(root.left,depth);
    }
}
```

2.按层遍历，取每层的最后一个节点。

```java
class Solution {
    
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>(); 
        if(root == null){
            return ans;
        }
        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0;i < size;i++){
                TreeNode cur = queue.poll();
                // 因为是右子树先放到队列中的，所以刚好是每一层遍历到的第一个节点，即为最右侧的节点
                if(i == 0){
                    ans.add(cur.val);
                }
                if(cur.right != null){
                    queue.add(cur.right);
                }
                if(cur.left != null){
                    queue.add(cur.left);
                }
            }
        }
        return ans;
    }
}
```

### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**题解：**

用递归实现，从低到上，分别计算每一个子树上的最大路径和，子树上的最大路径为：当前根节点值+左右子树上的最大路径值（最底层为节点值，其他层为根结点值 + 递归计算的左右子树中的最大路径值），然后层层往上递归，递归的同时累加最大路径和：节点值 + 左子树最大路径和（大于0才加） + 右子树最大路径和（大于0才加） 。

```java
class Solution {
    int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        maxNodeSum(root);
        return ans;
    }

    private int maxNodeSum(TreeNode root){
        if(root == null){
            return 0;
        }
        int leftSum = Math.max(maxNodeSum(root.left),0);
        int rightSum = Math.max(maxNodeSum(root.right),0);
				路径和 = 当前节点值 + 左子树最大路径和 + 右子树最大路径和
        ans = Math.max(ans,root.val + leftSum + rightSum);
       	// 当前子树的最大路径和
        return root.val + Math.max(leftSum,rightSum);
    }
}
```

### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

**题解：**

我们可以利用完全二叉树位置的性质来记录节点的位置，（根节点位置为0）一个节点的左子节点序号为 2*i + 1,右子节点的序号为 2*i+ 2.

因为这道题的节点值没有任何意义，所以可以把节点序号放在节点值中。同时用层序遍历来计算每一层的宽度，宽度为 ： 最后一个节点序号 - 第一个节点序号 + 1。宽度求最大值即答案。

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null){
            return 0;
        }
        Deque<TreeNode> queue = new ArrayDeque<>();
        root.val = 0;
        queue.add(root);
        int maxWidth = 0;
        while(!queue.isEmpty()){
            
            maxWidth = Math.max(maxWidth,queue.getLast().val - queue.getFirst().val + 1);
            int size = queue.size();
            for(int i = 0;i < size;i++){
                TreeNode cur = queue.poll();
                if(cur.left != null){
                    cur.left.val = cur.val * 2 + 1;
                    queue.add(cur.left);
                }
                if(cur.right != null){
                    cur.right.val = cur.val * 2 + 2;
                    queue.add(cur.right);
                }
            }
        }
        return maxWidth;
    }
}
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

**题解：**

1.递归，根据二叉搜索树的定义，左子树最大值小于根节点值，右子树最小值大于根节点值，左右子树也是二叉搜索树，所以递归需要3个信息，子树的最大值、最小值、是不是二叉搜索树，每次递归都返回这三个信息，然后再判断。时间复杂度O(n),空间复杂度 O(n)。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        return judgeBST(root).isBST;
    }

    private Info judgeBST(TreeNode root){
        if(root == null){
            return null;
        }
        Info leftInfo = judgeBST(root.left);
        Info rightInfo = judgeBST(root.right);
        // 最大值
        int max = root.val;
        // 最小值
        int min = root.val;
        // 左右子树是不是二叉搜索树
        boolean isBST = true;
        if(leftInfo != null){
            max = Math.max(max,leftInfo.max);
            min = Math.min(min,leftInfo.min);
            isBST = leftInfo.isBST && leftInfo.max < root.val ? true : false;
        }
        if(rightInfo != null){
            max = Math.max(max,rightInfo.max);
            min = Math.min(min,rightInfo.min);
            isBST = isBST && rightInfo.isBST && rightInfo.min > root.val ? true : false;
        }
        return new Info(min,max,isBST);

    }

    static class Info{
        int min;
        int max;
        boolean isBST;

        public Info(int min,int max,boolean isBST){
            this.min = min;
            this.max = max;
            this.isBST = isBST;
        }
    }
}
```

2.递归，搜索二叉树，如果左子树不为空，则左子树上所有节点值均小于它的根节点值；如果右子树不为空，则右子树上所有节点值大于根节点值。可以设计一个递归函数，判断左右子树的值是否在这个区间范围内，如果不满足返回false。否则继续调用递归函数判断它的左右子树是否为搜索二叉树。时间复杂度O(n),空间复杂度 O(n)。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }

    public boolean isValidBST(TreeNode root,long lower,long upper) {
        if(root == null){
            return true;
        }
        if(root.val <= lower || root.val >= upper){
            return false;
        }
        return isValidBST(root.left,lower,root.val) && isValidBST(root.right,root.val,upper);
    }
}
```

3.中序遍历。搜索二叉树基于终于遍历得到值构成的序列一定是升序的。所以中序遍历的时候检查当前节点值是否大于前一节点值即可。时间复杂度O(n),空间复杂度 O(n)。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
      Deque<TreeNode> stack = new LinkedList<TreeNode>();
      long inOrder = Long.MIN_VALUE;
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else {
                root = stack.pop();
                if(root.val <= inOrder){
                    return false;
                }
                inOrder = root.val;
                root = root.right;
            }
        }
        return true;
    }
}
```

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**题解：**

1.递归。对于任意一颗树而言，前序遍历的形式总是

```
[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
```


即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是

```
[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
```

所以可以先把中序遍历结果值作为key,对应位置作为value放到hashMap中，然后根据前序遍历的第一个节点值到hashMap中去找中序遍历对应的根节点位置，然后可以计算出左右子树的长度，又因为前序遍历和中序遍历的对应左右子树长度相同，从而可以用递归构造左右子树。

```java
class Solution {
    private Map<Integer, Integer> indexMap;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        indexMap = new HashMap<>();
        int n = inorder.length;
        // 将中序遍历结果作为key，位置作为值放到hashMap中
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);

    }

    private TreeNode myBuildTree(int[] preorder, int[] inorder, int preorderLeft, int preorderRight, int inorderLeft, int inorderRight) {
        if (preorderLeft > preorderRight) {
            return null;
        }
        // 先序遍历的第一个节点就是根节点,获取hashmap中根节点的位置（即中序遍历根节点的位置）
        int inRootIndex = indexMap.get(preorder[preorderLeft]);

        // 计算左子树有多少节点
        int leftSize = inRootIndex - inorderLeft;

        // 建立根节点
        TreeNode root = new TreeNode(preorder[preorderLeft]);
        // 左子树 前序遍历中左子树 从preorderLeft + 1 到 preorderLeft + leftSize,中序遍历左子树 从inorderLeft 到 inRootIndex - 1
        root.left = myBuildTree(preorder, inorder, preorderLeft + 1, preorderLeft + leftSize, inorderLeft, inRootIndex - 1);
        // 右子树 前序遍历 从preorderLeft + leftSize +1 到 preorderRight 中序遍历从 inRootIndex + 1 到 inorderRight
        root.right = myBuildTree(preorder, inorder,preorderLeft + leftSize +1,preorderRight,inRootIndex + 1 ,inorderRight);

        return root;
    }
    
}
```

### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

**题解：**

1.深度优先遍历，递归实现，每个节点的值都对应一个数字，计算每个节点对应的数字，然后累加所以节点对应的数字之和。如果是叶子结点则将对应数字累加，如果不是叶子结点，则计算对应结点的数字。时间复杂度O(n),空间复杂度O(n)。

```java
class Solution {
  	// 递归实现
    public int sumNumbers(TreeNode root) {
        return dfs(root,0);
    }

    private int dfs(TreeNode root,int preSum){
        if(root == null){
            return 0;
        }
        int sum = preSum * 10 + root.val;
        if(root.left == null && root.right == null){
            return sum;
        } else{
            return dfs(root.left,sum) + dfs(root.right,sum);
        }
    }
}
```

2.广度优先搜索，用两个队列，一个放节点，另外一个放该节点对应的值，如果一个节点是叶子结点直接累加，否则继续计算结点值。

```java
class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null){
            return 0;
        }
        // 广度优先搜索
        // 两个队列，分别用来保存结点、节点的数字值
        LinkedList<TreeNode> nodeQueue = new LinkedList<>();
        LinkedList<Integer> valueQueue = new LinkedList<>();
        nodeQueue.add(root);
        valueQueue.add(root.val);
        int sum = 0;
        while(!nodeQueue.isEmpty()){
            TreeNode node = nodeQueue.poll();
            int num = valueQueue.poll();
            TreeNode left = node.left,right = node.right;
            if(left == null && right == null){
                sum += num;
            } else {
                if(left != null){
                    nodeQueue.add(left);
                    valueQueue.add(num * 10 + left.val);
                }
                if(right != null){
                    nodeQueue.add(right);
                    valueQueue.add(num * 10 + right.val);
                }
            } 
        }
        return sum;
    }
}
```

### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

**题解：**

用递归深度优先遍历

```java
    class Solution {
      List<List<Integer>>  ans = new ArrayList<>();
      List<Integer> list = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root,0,targetSum);
        return ans;
    }

    private void dfs(TreeNode root, int sum ,int targetSum){
        if(root == null){
            return;
        }
        sum += root.val;
        list.add(root.val);
        if(sum == targetSum && root.left == null && root.right == null){
            ans.add(new ArrayList<>(list));
        }
        dfs(root.left,sum,targetSum);
        dfs(root.right,sum,targetSum);
        list.remove(list.size() - 1);
    }
}
```

### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

**题解：**

经过一个节点的最大路径是  左子树的最大路 + 右子树的最大路径 + 1，而经过一个节点的最大直径，其实就是最大直径 -1 ；用递归的方法进行深度优先遍历，取经过有所节点中的最大的最大路径即可。时间复杂度O(n),空间复杂度O(height)，height为二叉树高度。

```java
class Solution {
    int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return ans -1;
    }

    private int dfs(TreeNode root){
        if (root == null) {
            return 0;
        }
        int leftLength = dfs(root.left);
        int rightLength = dfs(root.right);
        ans = Math.max(ans,leftLength + rightLength + 1);
        return Math.max(leftLength,rightLength) + 1;
    }
}
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

**题解：** 对称二叉树，左右子树互为镜像，所以，左右子树根节点具有相同的值，每个树的右子树与另一棵树的左子树镜像对称。

1.实现一个递归函数，这样可以用两个指针p、q开始分别指向这棵树的左右结点，随后q右移、p左移，q左移、p右移。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        return check(root.left,root.right);
    }

    private boolean check(TreeNode q,TreeNode p){
        if(q == null && p == null){
            return true;
        }
        if(q == null || p == null){
            return false;
        }
        return q.val == p.val && check(q.left,p.right) && check(q.right,p.left);
    }
}
```

2.还可以把上面的递归函数改成迭代实现，用一个队列，分别把左右结点放到队列，然后一下弹出两个，然后再分别对成加入这两个节点的左右结点到队列中。

### [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

题解：用先序遍历、后序遍历或者层序遍历都可以实现序列化和反序列化。序列化的空位置也要记录。

```java
public class Codec {
		// 先序遍历递归实现
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder builder = new StringBuilder();
        preSerialize(builder,root);
        return builder.toString();
    }

    private void preSerialize(StringBuilder builder,TreeNode root){
        if (root == null) {
            builder.append("null").append(",");
        } else {
            builder.append(String.valueOf(root.val)).append(",");
            preSerialize(builder,root.left);
            preSerialize(builder,root.right);
        }

    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null) {
            return null;
        }
        String[] nodes = data.split(",");
        if (nodes.length == 0) {
            return null;
        }
        LinkedList<String> queue = new LinkedList<>();
        for (String note : nodes) {
            queue.add(note);
        }
        return preDeserialize(queue);

    }

    private TreeNode preDeserialize(LinkedList<String> queue) {
        String value = queue.poll();
        if ("null".equals(value)){
            return null;
        }
        TreeNode head = new TreeNode(Integer.parseInt(value));
        head.left = preDeserialize(queue);
        head.right = preDeserialize(queue);
        return head;
    }
}

```

### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

**题解：**

二叉搜索树，中序遍历时刚好是有序的（用递归遍历），同时右指针要指向比当前节点大的，左指针指向比当前节点小的节点，双向链表相邻节点构建关系需要设置前驱节点pre和当前节点cur，pre.right = cur,cur.left = pre，又因为是循环链表，需要头节点head，和尾节点tail(即pre)，tail.right = head,head.tail= pre。

```java
class Solution {
   Node pre,head; 
    public Node treeToDoublyList(Node root) {
        if(root == null){
            return null;
        }
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    private void dfs(Node cur){
        if(cur == null){
            return;
        }
        dfs(cur.left);
        if(pre == null) {
            head = cur;
        } else{
            pre.right = cur;
        }
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    }
}
```

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

**题解：**

深度优先搜索，如果一个位置为‘1’，则以其为起点开始进行深度搜索，搜索过程中，每个搜到的'1'都被标记为'0',然后继续搜索，搜索到的次数即为岛屿数量。

广度优先搜索：下次在看。

并查集：下次。

```java
class Solution {
    // 深度搜索实现
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0){
            return 0;
        }
        int vn = grid.length;
        int ln = grid[0].length;
        int num_Islands = 0;
        for(int v = 0 ; v < vn ;v++){
            for(int l = 0; l < ln ; l++){
                if(grid[v][l] == '1'){
                    num_Islands++;
                    dfs(grid,v,l);
                }
            }
        }
        return num_Islands;
    }

    private void dfs(char[][] grid,int v,int l){
        int vn = grid.length;
        int ln = grid[0].length;
        if(l < 0 || v < 0 || l >= ln || v >= vn || grid[v][l] == '0'){
            return;
        }
        grid[v][l] = '0';
        dfs(grid,v - 1,l);
        dfs(grid,v + 1,l);
        dfs(grid,v,l - 1);
        dfs(grid,v,l + 1);
    }
}
```

### [46. 全排列](https://leetcode.cn/problems/permutations/)

**题解：**

全排列，用回溯法，其实就是代码穷举，所有可能的结果。后面还要重新学习。

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> output = new ArrayList<>();
        for(int num : nums){
            output.add(num);
        }
        int n = nums.length;
        backtrack(n,output,ans,0);
        return ans;
    }

    private void backtrack(int n ,List<Integer> output,List<List<Integer>> ans,int first){
        // 所有数填完
        if(first == n ){
            ans.add(new ArrayList<Integer>(output));
        }
        for(int i = first; i < n ;i++){
            Collections.swap(output,first,i);
            // 递归下一个数
            backtrack(n,output,ans,first + 1);
            // 撤销
            Collections.swap(output,first,i);
        }
    }
}
```

### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

题解：

一次遍历，right长度的遍历，用两个变量分别记住反转链表前面的节点head1、反转链表部分反转后的尾结点tail。从头开始遍历，left开始反转，到rigth反转结束，结束后把反转链表部分反转后的头连接在head1下，tail连上反转区域外的下一个节点。时间复杂度O(right)。空间复杂度O(1).

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(head == null || left == right){
            return head;
        }
        int index = 1;
        ListNode cur = head;
        ListNode head1 = null;
        ListNode tail = null;
        ListNode pre = null;
        while(index <= right && cur != null){
            if(index < left){
                // 反转区域以外的上一个节点
                head1 = cur;
                cur = cur.next;
            } else {
                if (index == left){
                    // 记录反转区域的第一个节点，也即反转后的反转区域 尾结点
                    tail = cur;
                }
                ListNode nex = cur.next;
                cur.next = pre;
                pre = cur;
                if(index == right &&  tail != null){
                    // 如果从原链表的头节点开始反转，则新头为反转区域反转前的末尾节点
                    if (left == 1) {
                        head = cur;
                    } else if (head1 != null){
                        // 如果不是从原链表头节点开始反转，则反转区域外的上一个节点连接反转区域反转后的头节点
                        head1.next = cur;
                    }
                    // 反转区域反转后的尾结点连接上反转区域外的下一个节点
                    tail.next = nex;
                    break;
                }
                cur = nex;
            }
            index++;

        }
        return head;
    }
}
```

### [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

题解：

1.分治合并。两个链表合并，创建一个伪头head，还有一个tail,然后用两个指针ap、bp分别指向两个链表待比较的位置，ap.val、bp.val比大小，哪个小连到tail.next上，然后继续指向下一个位置，tail =tail.next。先两两的链表合并，再把这些合并好的链表合并。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists,0, lists.length - 1);
    }
		// 分治合并链表
    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }
        if (left > right) {
            return null;
        }
        int mid = (left + right) >> 1;
        return mergeTwoList(merge(lists,left,mid), merge(lists,mid + 1,right));
    }
		// 合并两链表
    private ListNode mergeTwoList(ListNode a,ListNode b){
        if (a == null || b == null){
            return a == null ? b : a;
        }
        ListNode head = new ListNode(0);
        ListNode tail = head,ap = a,bp = b;
        while (ap != null && bp != null) {
            if (ap.val < bp.val) {
                tail.next = ap;
                ap = ap.next;
            } else {
                tail.next = bp;
                bp = bp.next;
            }
            tail = tail.next;
        }
        tail.next = ap != null ? ap : bp;
        return head.next;
    }
}
```

2.用优先级队列，把所有链表的头节点放到队列中（通过比较器定义为小根堆），创建一个伪头head，还有一个tail,，然后每次弹出堆顶元素，连接在tail后面，然后继续把堆顶元素所在链表的下一个元素放到优先级队列中。直到堆为空。返回head.next.

```java
class Solution {
        public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> stack = new PriorityQueue<>(Comparator.comparingInt(a -> a.val));
        for (ListNode list : lists) {
            if (list != null) {
                stack.offer(list);
            }
        }
        ListNode head = new ListNode(0);
        ListNode tail = head;
        while (!stack.isEmpty()){
            ListNode node = stack.poll();
            tail.next = node;
            tail = tail.next;
            if (node != null && node.next != null) {
                stack.offer(node.next);
            }
        }
        return head.next;
    }
}
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

**题解：**

1.用HashSet,把节点元素不停往里放，直到里面有当前要放的元素，返回。

2.快慢指针。使用快慢指针fast、slow,都从头节点出发，慢指针移动一位，快指针移动两位，如果链表中有环，则它们一定会在环中相遇。环外走了a距离，slow入环后呀又走了b与fast相遇（fast在环中走了n圈）。所以fast走过的距离*a*+*n*(*b*+*c*)+*b*=*a*+(*n*+1)*b*+nc。又因为fast走的距离是slow走的两倍。所以*a*+(*n*+1)*b*+nc=2(*a*+*b*)⟹*a*=*c*+(*n*−1)(*b*+*c*)  -->  a=c+(n-1)(b+c)*a*=*c*+(*n*−1)(*b*+*c*) .               所以从链表头部到入环点的距离 等于 相遇点到入环点再加上 n-1圈环长。即相遇后把快指针放到头节点 一次移动一位继续走，当快慢指针再次撞上即入环点。![142_fig1](algorithm/142_fig1.png)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null){
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null){
            slow = slow.next;
            if(fast.next != null){
                fast = fast.next.next;
            } else {
                return null;
            }
            if(slow == fast){
                // 相遇后，快指针重新指向头节点
                fast = head;
                while(fast != slow){
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
}
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

题解：

1.模拟什么时候去变换访问方向，越界的或者访问了已经访问过的元素时变换方向。时间复杂O(nm),n,m分别为行和列。

2.分层遍历，每一层都可分为上层、右侧、下层、左侧四个遍历，通过定位四角的坐标，然后这四层分别去移动指针遍历即可。

```java
class Solution {
    // 模拟变换方向遍历
    public List<Integer> spiralOrder(int[][] matrix) {
        // 初始方向左上角，向右，当超出边界或者访问过之前访问过的元素，变换方向
        List<Integer> ans = new ArrayList<>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return ans;
        }
        int rows = matrix.length,columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int row = 0,column = 0;
        int[][] dircetions = {{0,1},{1,0},{0,-1},{-1,0}};
        int dircetionIndex = 0;
        int total = rows * columns;
        for(int i = 0;i < total ; i++){
            ans.add(matrix[row][column]);
            visited[row][column] = true;
            int nextRow = row + dircetions[dircetionIndex][0], nextColumn = column + dircetions[dircetionIndex][1];
            if(nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]){
                dircetionIndex = (dircetionIndex + 1) % 4;
            }
            row += dircetions[dircetionIndex][0];
            column += dircetions[dircetionIndex][1];
        }
        return ans;
    }
}
```

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        // 按层遍历
        List<Integer> ans = new ArrayList<>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return ans;
        }
        int rows = matrix.length,columns = matrix[0].length;
        int left = 0,right = columns -1,top = 0,bottom = rows -1;
        while(left <= right && top <= bottom){
            // 遍历上层
            for(int column = left; column <= right;column++){
                ans.add(matrix[top][column]);
            }
            // 遍历右侧列
            for(int row = top + 1; row <= bottom;row++){
                ans.add(matrix[row][right]);
            }
            // 当 left < right && top < bottom 时遍历下层和左侧列
            if(left < right && top < bottom){
                // 遍历下层
                for(int column = right -1; column > left;column--){
                    ans.add(matrix[bottom][column]);
                }
                // 遍历左侧列
                for(int row = bottom; row > top;row--){
                    ans.add(matrix[row][left]);
                }
            }
            left++;
            top++;
            right--;
            bottom--;
           
        }
        return ans;
    }
}
```



### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

题解：

1.动态规划：计算以元素a结尾的字数组中最长递增子序，然后一直遍历到最后，取长度最大的递增子序

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxnums = 1;
        for(int i = 1; i < nums.length;i++){
            dp[i] = 1;
            for(int j = 0;j < i ;j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }
            maxnums = Math.max(maxnums,dp[i]);
        }
        return maxnums;
    }
}
```

2.动态规划+二分查找：nums[],上面内循环时间复杂度为O(n),改用二分查找，时间复杂度将为O(NlogN)。有个res[]数组，如果nums[]中i位元素大于res最后元素直接追加在res[]末尾，否则就替换在res数组中比nums[]中i位元素大的最小值。最长递增子序列长度即位res[]长度（可能最长递增子序列不是res[],但长度是它的长度）

```java
     public int lengthOfLIS(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int len = 1;
        int[] res = new int[nums.length + 1];
        res[len] = nums[0];
        for(int i = 1; i < nums.length;i++){
            // 如果i位置元素大于结果集中最后元素，则直接追加在后面
            if (nums[i] > res[len]) {
                res[++len] = nums[i];
            } else {
                // 否则，放到res中比nums数组中i位置元素大的最小值位置
                int left = 1,right = len,pos = 0;
                while (left <= right) {
                    int mid = (left + right) >> 1;
                    if (res[mid] < nums[i]) {
                        pos = mid;
                        left = mid + 1;
                    } else {
                        right = mid -1;
                    }
                }
                res[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

题解：

1.动态规划：分别用两个数组leftMax、rightMax来保存下标i的左边最大高度和右边最大高度，然后遍历到每一个下标时，用该索引对应的左右最大高度中最小的那个减去下标i对应的高度，即是下标i位置能储存的水，所有的加起来。时间复杂度O(n),空间复杂度O(n)。

```java
class Solution {
    public int trap(int[] height) {
        if(height == null || height.length <= 2){
            return 0;
        }
        int n = height.length;
        int[] leftMax = new int[n];
        int[] rightMax = new int[n];
        leftMax[0] = height[0];
        for(int i = 1;i < n - 1;i++){
            leftMax[i] = Math.max(height[i],leftMax[i -1]);
        }
        rightMax[n - 1] = height[n - 1];
        for(int j = n -2;j >= 0;j--){
            rightMax[j] = Math.max(height[j],rightMax[ j+ 1]);
        }
        int sum = 0;
        for(int k = 1; k < n - 1 ;k++){
            sum+= Math.min(rightMax[k],leftMax[k]) - height[k];
        }
        return sum;
    }
}
```

2.双指针法：left、right分别从左向右移动、从右向左移动。对于整个数组，假设左边最大高度小于右边最大高度，那么从左向右移动的过程中，计算雨水Math.max(0,leftMax - height[left]) （其实此时只要还是在leftMax < rightMax范围内，rightMax就对计算过程没有任何影响）；反之也是。所有的结果加起来即是接的雨水。时间复杂度O(n),空间复杂度O(1)。

```java
class Solution {
    public int trap(int[] height) {
        if(height == null || height.length <= 2){
            return 0;
        }
        int n = height.length ,sum = 0;
        int leftMax = height[0],rightMax = height[n - 1];
        int left = 0,right = n -1;
        while(left <= right){
            if(leftMax < rightMax){
                sum+=Math.max(0,leftMax - height[left]);
                leftMax = Math.max(height[left],leftMax);
                left++;
            } else{
                sum+=Math.max(0,rightMax - height[right]);
                rightMax = Math.max(height[right],rightMax);
                right--;
            }
        }
        return sum;
    }
}
```

### [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

题解：

1.用线性表：把节点放到线性表中，然后同时从头和尾进行遍历连接。时间复杂度O(N),空间复杂度O(n).

```java
class Solution {
    public void reorderList(ListNode head) {
        // 用线性表 存放节点，然后分别从两端遍历连接
        LinkedList<ListNode> list = new LinkedList<ListNode>();
        ListNode node = head;
        while(node != null){
            list.add(node);
            node = node.next;
        }
        int left = 0, right = list.size() - 1;
        while(left < right){
            list.get(left).next = list.get(right);
            left++;
            if(left == right){
                break;
            }
            list.get(right).next = list.get(left);
            right--;
        }
        list.get(left).next = null;
    }
}
```

2.找到链表中点+链表逆序+合并链表：先找到链表的中点(用快慢指针来找到链表中点)，然后再把右半部分链表反转，最后再把链表合并起来。时间复杂度O(N),空间复杂度O(1).

```java
class Solution {
    public void reorderList(ListNode head) {
        if(head == null){
            return;
        }
        // 先找到中点
        ListNode mid = findMid(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null;
        // 反转右半部分链表
        l2 = reverseList(l2);
        // 合并链表
        mergeList(l1,l2);
    }

    private ListNode findMid(ListNode head){
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    private ListNode reverseList(ListNode head){
        ListNode prev = null;
        ListNode curr = head;
        while(curr != null){
           ListNode nextTemp = curr.next;
           curr.next = prev;
           prev = curr;
           curr = nextTemp; 
        }
        return prev;
    }

    private void mergeList(ListNode l1,ListNode l2){
        ListNode l1Temp = null;
        ListNode l2Temp = null;
        while(l1 != null && l2 != null){
            l1Temp = l1.next;
            l2Temp = l2.next;

            l1.next = l2;
            l1 = l1Temp;

            l2.next = l1;
            l2 = l2Temp;
        }
    }
}
```

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

1.题解：一个栈inStack用来存放添加进来的元素，一个outStack用来存放要弹出的元素，队列pop或者peek的时候，判断outStack是否为空，如果为空，则把inStack里面的元素倒进outStack中，再调用outStack的pop或者peek方法。（为何要outStack为空时再把inStack元素倒进outStack？因为只有当outStack为空时，最后添加进来的元素在inStack栈顶，然后才能倒入outStack的栈底，inStack栈底元素，才能倒入outStack的栈顶，保证队列先进先出的顺序）

```java
class MyQueue {
    private Deque<Integer> inStack;
    private Deque<Integer> outStack;

    public MyQueue() {
        inStack = new ArrayDeque();
        outStack = new ArrayDeque<>();
    }
    
    public void push(int x) {
       inStack.push(x);
    }
    
    public int pop() {
        if (outStack.isEmpty()) {
            inToOut();
        }
        return outStack.pop();
    }
    
    public int peek() {
        if (outStack.isEmpty()) {
            inToOut();
        }
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    private void inToOut() {
        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
}
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

题解：先按照区间左端点排序，然后遍历，放到一个新的list中，如果遍历到的数组左端点比list中最后一个元素的右端点大，说明无法合并，则直接把当前数组放到list中；反之则更新list中最后一个元素的右端点为（list中最后一个元素的右端点和 当前遍历到的数组右端点中较大的值）。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][2];
        }
        Arrays.sort(intervals, (o1, o2) -> o1[0] - o2[0]);
        ArrayList<int[]> merged = new ArrayList<>();
        for (int[] interval : intervals) {
            int left = interval[0], right = interval[1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < left) {
                merged.add(interval);
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], right);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

题解：动态规划，爬第n阶楼梯的方法数等于 爬第n-1阶楼梯的方法数 和 爬第n-2阶楼梯的方法数的和。（其实就是斐波那契数列），可以设 0 阶台阶方法数为1，1阶方法数其实也为1.

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n ; i++){
            dp[i] = dp[i -1] + dp[i -2];
        }
        return dp[n];
    }
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

题解：

1.找到链表的长度L，然后遍历到第 L - n 个节点处，移动next指针。

2.把链表节点放到栈中，然后弹出n + 1 个，然后把这第n + 1个的next指针移动到第n个节点的下一个节点上。

3.双指针：用两个指针first（开始指向头节点）、second ，first比second超前n个节点，当first直到末尾节点时，second刚好知道倒数第n个节点上，又因为second指针知道倒数第n个节点的前置节点时更容易操作，所以把second指针开始指向假节点。

```java
class Solution {

     public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode first = head;
        ListNode second = dummy;
        for (int i = 0; i < n; i++) {
            first = first.next;
        }
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        return dummy.next;
    }
}
```

### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

题解：一次遍历即可，遍历的过程中判断当前节点和下一节点值是否相同，如果相同，则把next指针移动到下一节点的下一节点，如此操作下去，直到没有值相同的节点，由于操作过程中可能会把头节点删掉，所以用一个伪头放在头节点前。

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
       if(head == null){
           return head;
       }
        ListNode dummy = new ListNode(0,head);
        ListNode curr = dummy;
        while(curr.next != null && curr.next.next != null){
            if(curr.next.val == curr.next.next.val){
                int x = curr.next.val;
                while(curr.next != null && curr.next.val == x){
                    curr.next = curr.next.next;
                }
            } else{
                curr = curr.next;
            }
        }
        return dummy.next;
       
    }
}
```

### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

题解：见官方题解，如下代码为划分数组法（其实也是一种二分查找方法）

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 认为 nums1长度小于nums2长度
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        int m = nums1.length;
        int n = nums2.length;

        int left = 0, right = m;
        // 前一部分最大值
        int median1= 0;
        // 后一部分最小值
        int median2= 0;
        while (left <= right) {
            // 前一部分包含 nums1[0 ~ i-1] 和 nums2[0 ~ j-i]
            // 后一部分包含 nums1[i ～ m-1] 和 nums2[j ~ n-1]
            int i = (left + right) >> 1;
            int j = (m + n + 1) / 2 - i;

            // nums1_im、nums1_i、nums2_jm、nums2_j分别表示nums1[i - 1]、nums1[i]、nums1[j -1]、nums1[j]
            int nums1_im = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
            int nums1_i = i == m ? Integer.MAX_VALUE : nums1[i];
            int nums2_jm = j == 0 ? Integer.MIN_VALUE : nums2[j -1];
            int nums2_j = j == n ? Integer.MAX_VALUE : nums2[j];
            if (nums1_im<= nums2_j) {
                median1 = Math.max(nums1_im, nums2_jm);
                median2 = Math.min(nums1_i, nums2_j);
                left = i + 1;
            } else {
                right = i - 1;
            }
        }

        return (m + n ) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
    }
}
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

题解：动态规划。`dp[i][j]` 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数；需要考虑 word1 或 word2 一个字母都没有，即全增加/删除的情况，所以预留 `dp[0][j]` 和 `dp[i][0]`

```
状态转移
增，dp[i][j] = dp[i][j - 1] + 1
删，dp[i][j] = dp[i - 1][j] + 1
改，dp[i][j] = dp[i - 1][j - 1] + 1
按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了
配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小
如果刚好这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1]取最小 ，操作不用加一
```

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n1 = word1.length() + 1,n2 = word2.length() + 1;
        int[][] dp = new int[n1][n2];
        //1. 需要考虑 word1 或 word2 一个字母都没有，即全增加/删除的情况，所以预留 dp[0][j] 和 dp[i][0]
        for(int i = 0;i < n1;i++){
            dp[i][0] = i;
        }
        for(int j = 0;j < n2;j++){
            dp[0][j] = j;
        }
        //2.dp[i][j] = Math.min(dp[i - 1][j] ,dp[i][j - 1] , dp[i - 1][j - 1]) + 1
        for(int i = 1;i < n1;i++){
            for(int j = 1;j < n2;j++){
            int minDp = Math.min(dp[i - 1][j],dp[i][j - 1]);
            dp[i][j] = Math.min(minDp, dp[i - 1][j - 1]) + 1;
            if(word1.charAt(i - 1) == word2.charAt(j - 1)){
                //3 这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] 
                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
            }
            }
        }
        return dp[n1 - 1][n2 -1];
	    
    }
}
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

题解：归并排序（采用的是分治算法），采用自底向上的归并排序方法，时间复杂度O(n log n)，空间复杂度O(1)。先求出链表长度，然后按步长为1开始mergeSort划分好的每两段链表，当步长为1排序完后，步长*2继续排序，直到步长不小于链表长度。

```java
class Solution {
  public  ListNode sortList(ListNode head) {
       if(head == null){
           return head;
       }
       int length = 0;
       ListNode node = head;
       while(node != null){
           length++;
           node = node.next;
       }
       ListNode dummyHead = new ListNode(0,head);
       for(int subLength = 1; subLength < length;subLength <<= 1){
           ListNode prev = dummyHead,curr = dummyHead.next;
           while(curr != null){
               ListNode head1 = curr;
               for(int i = 1;i < subLength && curr.next != null;i++){
                   curr = curr.next;
               }
               ListNode head2 = curr.next;
               curr.next = null;
               curr = head2;
             	 // 考虑到右边分组时，上面的curr可能已经为空
               for(int j = 1;j < subLength && curr != null && curr.next != null;j++){
                   curr = curr.next;
               }
               ListNode next = null;
               if(curr != null){
                   next = curr.next;
                   curr.next = null;
               }
               // 归并排序
               ListNode merged = merge(head1,head2);
               prev.next = merged;
               while(prev.next != null){
                   prev = prev.next;
               }
               curr = next;
           }
       }
       return dummyHead.next;
    }

    private ListNode merge(ListNode head1,ListNode head2){
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead,temp1 = head1,temp2 = head2;
        while(temp1 != null && temp2 != null){
            if(temp1.val < temp2.val){
                temp.next = temp1;
                temp1 = temp1.next;
            } else{
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if(temp1 != null){
            temp.next = temp1;
        } else if(temp2 != null){
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}
```

### [8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)

题解：直接按照题目跳过空格，解析正负符号，解析数字（解析过程中处理解析出来的整数越界的问题），如果遇到解析数字过程中如果遇到非数字直接结束。

```java
class Solution {
    public static int myAtoi(String s) {
        int sign = 1,i = 0,n = s.length();
        long ans = 0;
        // 跳过空格
        while(i < n && s.charAt(i) == ' '){
            i++;
        }
        // 获取正负符号
        if(i < n && (s.charAt(i) == '-' || s.charAt(i) == '+' )){
            sign = s.charAt(i) == '-' ? -1 : 1;
            i++;
        }
        //读取数字
        for(;i < n ;i++){
            // 如果是数字
            if(s.charAt(i) >= '0' &&  s.charAt(i) <= '9'){
                // 如果越界整数范围
                ans = ans * 10 + s.charAt(i) - '0';
                if (ans > (long) Integer.MAX_VALUE) {
                   return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
                }
            } else {
                // 不是数字，直接结束
                break;
            }
        }
        return (int)(sign * ans);
    }
}
```

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

题解：双指针。用快慢指针，快指针比慢指针超前k，当快指针到链表结尾，刚出链表时，慢指针所指的就是倒数第k个节点。

```java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode slow = head;
        ListNode fast = head;
        for(int i = 0; i < k && fast != null;i++){
            fast = fast.next;
        }
        while(fast != null && slow != null){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

题解：置换法。如果数组中包含 *x*∈[1,*N*]，（n为数组长度）数组没有缺失正整数是：数字x对应放置在 x-1的位置，所以我们要把范围内的数字放到对应的位置去。（就是把出现的数字x和 x-1位置的数交换）如果 x = nums[x-1],会出现无限交换，所以就判断当 x = nums[x-1]时，说明x已经出现在了正确的位置上，跳出循环继续交换下一个数。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i = 0 ;i < n ;i++){
            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        for(int i = 0 ;i < n ;i++){
           if(nums[i] != i +1){
               return i+ 1;
           }
        }
        return n + 1;
    }
}
```

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

题解：回溯法，在序列有效的时候继续添加 ‘(’ 或 }‘)’，如果左括号数量不大于 *n*，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。(这里用剩余的未填充括号来表示)

```java
class Solution {
     public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<String>();
        if (n <= 0) {
            return ans;
        }
        getParenthesis(ans, "", n, n);
        return ans;
    }

    private void getParenthesis(List<String> ans, String str, int left, int right) {
        // 如果左右括号填充完成且匹配，放入答案中
        if (left == 0 && right == 0) {
            ans.add(str);
            return;
        } else if (left == right) {
            // 剩余左右括号相等，继续填充左括号
            getParenthesis(ans,str+"(",left - 1,right);
        } else if (left < right) {
            // 如果剩余为填充的右括号多于左括号，左右括号都可以填充
            if (left > 0) {
                getParenthesis(ans, str + "(", left - 1, right);
            }   // 用右括号继续填充
            getParenthesis(ans, str + ")", left, right -1);

        }

    }
}
```

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

题解：两遍扫描。1.从后向前找到满足 a[i] < a[i+1]的i；2.如果i存在，在[i+1,n) 中从后向前查找第一个元素j满足 a[i] < a[j]，交换i、j元素；3.此时[i+1,n)为降序，用双指针法，反转为升序。（步骤1如果没有找到满足条件的i，则证明当前序列时最大序列，跳过步骤2，直接执行步骤3）

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length -2;
        // 找到i满足 a[i] < a[i+1]
        while(i >= 0 && nums[i] >= nums[i+ 1]){
            i--;
        }
        // 如果i存在，在[i+1,n) 中从后向前查找第一个元素j满足 a[i] < a[j]
        if(i >= 0){
            int j = nums.length -1;
             while(j >= 0 && nums[i] >= nums[j]){
                j--;
             }
             swap(nums,i,j);
        }
        // [i+1,n)区间降序，通过交换变为升序，如果没找到满足条件的i，则证明当前序列时最大序列，跳过步骤2，直接执行3，变为最小序列
        reverse(nums,i + 1);
    }
    private void swap(int[] nums,int i ,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums,int start ){
        int left = start,right = nums.length -1;
        while(left < right){
             swap(nums,left,right);
             left++;
             right--;
        }
    }
}
```

### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

题解：动态规划。创建 m+1 行 n+1 列的二维数组 dp，其中`dp[i][j] `表示`text1[0:i] `和text2[j:0]的最长公共子序列的长度。1.当其中至少一个字符串为空时，公共子序列为空，所以`dp[0][0]`= 0。2.当新出现一个公共字符时，`dp[i][j] = dp[i -1][j -1] + 1;`;3.当没有前一步没有公共字符时，`dp[i][j] = Math.max(dp[i][j -1],dp[i -1][j])`.

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(),n = text2.length();
        int[][] dp = new int[m+1][n+1];
        for(int i = 1;i <= m;i++){
            char c1 = text1.charAt(i - 1);
           for(int j = 1;j <= n;j++){
                char c2 = text2.charAt(j - 1);
                if(c1 == c2){
                    dp[i][j] = dp[i -1][j -1] + 1;
                } else{
                    dp[i][j] = Math.max(dp[i][j -1],dp[i -1][j]);
                }
            } 
        }
        return dp[m][n];
    }
}
```

### [复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

题解：回溯法。根据ip地址的特点分为4个ip段段去枚举，考虑到不能有0前导，所以0只能是单独的ip段。

```java
class Solution {
    static final int SEG_COUNT = 4;
    List<String> ans = new ArrayList<>();
    int[] segments = new int[SEG_COUNT];
    public List<String> restoreIpAddresses(String s) {
     dfs(s,0,0);
     return ans;   
    }

    private void dfs(String s,int segId ,int segStart){
        // 如果找到了4段ip，且遍历完了字符串，则答案确定
        if(segId == SEG_COUNT){
            if(segStart == s.length()){
                StringBuilder str = new StringBuilder();
                for(int i = 0;i < SEG_COUNT;i++){
                    str.append(segments[i]);
                    if(i != SEG_COUNT -1){
                         str.append(".");
                    }
                }
                ans.add(str.toString());
            }
            return;
        }

        // 如果没找到4个ip段，就遍历完字符串，直接回溯
         if(segStart == s.length()){
             return;
         }
         // 如果字符串为0，由于不能有0前导，所以0只能是单独的ip段
         if(s.charAt(segStart) == '0'){
             segments[segId] = 0;
             dfs(s,segId + 1,segStart + 1);
         }
         // 一般情况，枚举每一种可能
         int addr =0;
         for(int segEnd = segStart;segEnd < s.length();segEnd++){
             addr = addr * 10 + (s.charAt(segEnd) - '0');
             if(addr >0 && addr <= 255){
                 segments[segId] = addr;
                 dfs(s,segId + 1,segEnd + 1);
             } else {
                 break;
             }
         }

    }
}
```

### [151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

题解：双端队列。由于双端队列支持从队列头部插入的方法，因此我们可以沿着字符串一个一个单词处理，然后将单词压入队列的头部，再将队列转成字符串即可。

```java
class Solution {
    public String reverseWords(String s) {
        int left = 0,right = s.length() -1;
        // 去掉头部的空格
        while(left <= right && s.charAt(left) == ' '){
            left++;
        }
        // 去掉尾部的空格
          while(left <= right && s.charAt(right) == ' '){
            right--;
        }
        // 字符串压入队列头部
        Deque<String> queue = new ArrayDeque<>();
        StringBuilder str = new StringBuilder();
        while(left <= right){
            char c = s.charAt(left);
            if(str.length() != 0 &&  c == ' '){
                queue.addFirst(str.toString());
                str.setLength(0);
            } else if(c != ' '){
                str.append(c);
            }
            left++;
        }
        queue.addFirst(str.toString());
        // 队列加入空格转为字符串
        return String.join(" ",queue);
    }
}
```

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

题解：用单调队列。用一个单调队列保存数组移动窗口的下标。如果新添加的下标对应的元素值大于队列尾元素（队列尾下标其实是未新增前最新的元素）对应的值，说明队列尾下标不需要了（说明它不是窗口内的的最大值），那就移除队列尾元素，直到队列为空或者新增元素对应值小于队列尾元素对应值（前面说明该队列中元素对应值为单调递减）。保持窗口长度为k继续遍历，同时删除队列中窗口外的下标，收集窗口内最大值（队列头元素对应值即为窗口内最大值）。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new LinkedList<Integer>();
        // 先遍历k个元素长度
        for(int i = 0;i < k;i++){
            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        int[] ans = new int[nums.length - k + 1];
        ans[0] = nums[deque.peekFirst()];
        // 移动指针，保持窗口长度为k
        for(int i = k; i < nums.length ;i++){
            // 如果当前元素对应值大于队列末尾元素对于值，说明对列尾对应元素已无效
            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);
            // 保持窗口长度为k，删除窗口外下标
            while(deque.peekFirst() <= i - k){
                deque.pollFirst();
            }
            // 收集每次指针移动窗口中的最大值
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
      
        return ans;
    }
}
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

题解：用滑动窗口。用两个指针left、right分别表示窗口的左右边界，right用于扩展窗口，left用于收缩窗口。然后用两个hash表分别存放字符串t 中字符（key）以及对应的个数（value），窗口字符串中字符（key）以及对应的个数（value），当窗口包含t中所有字符且数量大于等于t中对应字符数，可以尝试向右移动left指针。去除最后左右指针之间的字符串即为最小覆盖字符串。(这里用数组代替hash表，因为字符ASCII码可以作为数组下标)。

```java
class Solution {
    int[] tArr = new int[128];
    int[] wArr = new int[128];
    public String minWindow(String s, String t) {
        
        // 先把t中字符串放到map中
        int tLen = t.length();
        for(int i = 0;i < tLen;i++){
            tArr[t.charAt(i)]++;
        }

        // 移动窗口
        int left = 0,right = -1;
        // 最小字符串位置
        int subLeft = -1,subRight = -1;
        int sLen = s.length();
        int len = sLen;
        while(right < sLen){
            right++;
            if(right < sLen && tArr[s.charAt(right)] > 0){
                wArr[s.charAt(right)]++;
            }
            // 如果窗口包含全部s字符串，移动左指针
            while(check() && left <= right){
                // 给窗口截取赋值
                if(right - left + 1 <= len){
                    len = right - left + 1;
                    subLeft = left;
                    subRight = subLeft + len;
                }
                if(tArr[s.charAt(left)] > 0){
                    wArr[s.charAt(left)]--;
                }
                left++;
            }
        }
        return subLeft == -1 ? "" : s.substring(subLeft,subRight);

    }
    private boolean check(){
        for (int i = 0; i < tArr.length; i++) {
            if (wArr[i] < tArr[i]) {
                return false;
            }
        }
        return true;
    }
}
```

### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

题解：动态规划。1.`s[i]=‘)’ 且 s[i - 1] =‘(’，也就是字符串形如 “……()”“……()”，我们可以推出：dp[i]=dp[i−2]+2`

2.`s[i] = ‘)’ 且 s[i−1]=‘)’，也就是字符串形如 “……))”“……))”，我们可以推出：如果 s[i− dp[i−1] -1]=‘(’，那么 dp[i]= dp[i−1] + dp[i−dp[i−1]−2]+2`,因为如果s[i−1]对应的前面有个'('，然后这个'('前面还有个'('和s[i] = ‘)’ 配对，此时应该是`dp[i]=dp[i−1]+2`,同时还要考虑和s[i] = ‘)’ 配对的'('前面位置，所以再加上dp[i−dp[i−1]−2]。

```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int ans = 0;
        for(int i = 1; i < s.length();i++){
            if(s.charAt(i) == ')'){
                if(s.charAt(i -1) == '('){
                    dp[i] = (i >= 2 ? dp[i -2] : 0 )+ 2;
                } else if(i - dp[i -1] > 0 && s.charAt(i - dp[i -1] -1) == '('){
                    dp[i] = dp[i -1] + (i - dp[i -1] >= 2 ? dp[i - dp[i -1] -2] : 0 ) + 2;
                }
                 ans = Math.max(ans,dp[i]);
            }
        }
        return ans;
    }
}
```

左右计数器法：利用两个计数器left和right。首先从左到右遍历，对于遇到的每个'('，left++;对于遇到的每个')',right++，当left== right时计算有效字符串长度，当left < right时，两计数器都变成0，不过这样会有(()这种情况会漏掉，那就反过来，从右往左遍历：当left== right时计算有效字符串长度，当left > right时，两计数器都变成0.

```java
class Solution {
    public int longestValidParentheses(String s) {
       int left = 0, right = 0,maxLength = 0;
       for(int i = 0 ;i < s.length() ;i++){
           if(s.charAt(i) == '('){
               left++;
           } else{
               right++;
           }
           if(left == right){
               maxLength = Math.max(maxLength,right * 2);
           } else if(right > left){
               left = right = 0;
           }
       }
        left = right = 0;
       for(int i =  s.length() - 1 ;i >=0  ;i--){
           if(s.charAt(i) == '('){
               left++;
           } else{
               right++;
           }
           if(left == right){
               maxLength = Math.max(maxLength,right * 2);
           } else if(left > right){
               left = right = 0;
           }
       }
        return maxLength;
    }
}
```

### [43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

题解：用竖乘法。如果num1和num2长度分别为m、n,乘积最大长度为m+ n，位位相乘到的结果放到数组中，然后再在数组中处理进位问题，最后再把数组转成字符串，如果高位是0则舍弃高位。`对于任意 0≤ i <m 和 0≤ j <n，num1[i]×num2[j] 的结果位ansArr[i+j+1]，如果ansArr[i+j+1]≥10，则将进位部分加到 ansArr[i+j]。`(小的是高位)。

```java
class Solution {
    public String multiply(String num1, String num2) {
        if("0".equals(num1) || "0".equals(num2)){
            return "0";
        }
        int[] ans = new int[num1.length() + num2.length()];
        int ansLen = ans.length;
        // 分位分别计算乘积
        for(int i = num1.length() -1; i >= 0 ;i--){
            int n1 = num1.charAt(i) - '0';
            for(int j = num2.length() -1; j >= 0 ;j--){
                int n2 = num2.charAt(j) - '0';
                ans[i + j + 1] += n1 * n2;
            }
        }
        // 处理数组中乘积进位
        for(int i = ansLen - 1;i > 0;i--){
            ans[i - 1] += ans[i]/10; 
            ans[i] %=10;
        }
        // 判断高位是否为0，为0舍弃高位
        int index = ans[0] == 0 ? 1 : 0;
        StringBuilder ansStr = new StringBuilder();
        while(index < ansLen){
            ansStr.append(ans[index++]);
        }
        return ansStr.toString();
    }
}
```



### [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)

题解：根据点拆分成String数组，然后分段转成整数比较。

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        if(version1 == null || version2 == null){
            return 0;
        }
        String[] strArr1 = version1.split("\\.");
        String[] strArr2 = version2.split("\\.");
        for(int i = 0; i < strArr1.length || i < strArr2.length; i++){
           int x =0  ,y = 0;
           if(i < strArr1.length){
               x = Integer.parseInt(strArr1[i]);
           }
           if(i < strArr2.length){
               y = Integer.parseInt(strArr2[i]);
           }
           if(x > y){
               return 1;
           } else if(x < y){
            return -1;
           }
        }
        return 0;
    }
}
```

2.双指针法。把版本号直接转化为整数去比较，遇到点直接跳过。

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        if(version1 == null || version2 == null){
            return 0;
        }
        int m = version1.length(), n = version2.length();
        int i = 0,j = 0;
        while(i <m || j < n){
            int x = 0,y = 0;
            for(;i < m && version1.charAt(i) != '.';i++){
                x = x * 10 + version1.charAt(i) - '0';
            }
            i++;// 跳过点号
            for(;j < n && version2.charAt(j) != '.';j++){
                y = y * 10 + version2.charAt(j) - '0';
            }
            j++;// 跳过点号
            if(x != y){
                return x > y ? 1 : -1;
            }
        }
        return 0;
    }
}
```

### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

题解：动态规划。创建二维数组dp，与原始网格的大小相同，`dp[i][j]` 表示从左上角出发到 `(i,j)` 位置的最小路径和。显然，`dp[0][0]=grid[0][0]`。对于dp 中的其余元素，通过以下状态转移方程计算元素值。

当` i>0 `且`j=0` 时，`dp[i][0]=dp[i−1][0]+grid[i][0]`。(从第二行开始的第一列)

当 `i=0` 且 `j>0` 时，`dp[0][j]=dp[0][j−1]+grid[0][j]`。(从第二列开始的第一行)

当 `i>0` 且 `j>0` 时，`dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]`。( 第二行、第二列开始往后)

最后得到 `dp[m−1][n−1]` 的值即为从网格左上角到网格右下角的最小路径和。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length ==0){
            return 0;
        }
        int rows = grid.length,columns = grid[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = grid[0][0];
        // 从第二行开始的第一列
        for(int i = 1; i < rows;i++){
            dp[i][0] = dp[i -1][0] + grid[i][0];
        }
        // 从第二列开始的第一行
        for(int j = 1; j < columns ;j++){
            dp[0][j] = dp[0][j -1] + grid[0][j];
        }
        // 第二行、第二列开始往后
        for(int i = 1; i < rows;i++){
           for(int j = 1; j < columns ;j++){
             dp[i][j] = Math.min(dp[i -1][j],dp[i][j -1]) + grid[i][j];
            }
        }
        return dp[rows -1][columns -1];
    }
}
```

### [78. 子集](https://leetcode.cn/problems/subsets/)

题解：二进制枚举。分别用0、1代表一个元素是否在子集中，所有的枚举数从0到2^n^ -1,我们可以枚举mask∈[0,2^n^−1],mask表示0/1二进制表，然后在原集合中取数，枚举完2^n^个mask，刚好构造出所有子集。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {

        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> temp =  new ArrayList<>();
        int n = nums.length;
        for(int mask = 0 ; mask < (1 << n) ;mask++){
            temp.clear();
            for(int i = 0; i < n ;i++){
                if((mask & (1 << i)) != 0){
                    temp.add(nums[i]);
                }
            }
            ans.add(new ArrayList<Integer>(temp));
        }
        return ans;
    }
}
```

回溯法。见如下代码。dfs(*cur*,*n*)，cur表示当前位置，n表示数组长度。原列表中的每个元素都有选中和不被选中两种情况，用集合t存放已被选中的元素。在进入`dfs(cur,n)` 之前`[0,cur−1]` 位置的状态是确定的，而 `[cur,n−1]` 内位置的状态是不确定的，所以dfs(cur,n)要确定cur状态，然后解决[cur,n−1]子集问题。cur位置元素取，则放到t集合中，然后继续执行dfs(cur + 1,n)，然则对t回溯；cur位置元素取若不取，则直接继续执行dfs(cur + 1,n)。

关于回溯法：1.递归方法的参数 2.要有出口，3.走一步（就是包含某个结果）退一步（就是包含这个结果）这里就是回溯

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> t =  new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(0,nums);
        return ans;
    }
    private void dfs(int cur,int[] nums){
        // 出口
        if(cur == nums.length){
            ans.add(new ArrayList<>(t));
            return;
        }
        // 如果cur位置元素取
        t.add(nums[cur]);
        dfs(cur + 1,nums);
        // 对t回溯cur位置元素，当cur位置元素不取，那删除t中cur位置元素继续处理
        t.remove(t.size() - 1);
        dfs(cur + 1,nums);
    }
}
```

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

题解：动态规划。我们采用自下而上的方式进行思考。定义 `F(i)` 为组成金额 i 所需最少的硬币数量，假设在计算 `F(i)` 之前，我们已经计算出 `F(0)−F(i−1)` 的答案。 则 F(i) 对应的转移方程应为
		F( i ) = min~j=0…n−1~ F(i−c~j~)+1

其中 c~j~代表的是第 j 枚硬币的面值，即我们枚举最后一枚硬币面额是 c~j~，那么需要从 i-c~j~这个金额的状态F(i−c~j~ ) 转移过来，再算上枚举的这枚硬币数量 1 的贡献，由于要硬币数量最少，所以 F(i) 为前面能转移过来的状态的最小值加上枚举的硬币数量 1 。时间复杂度O(Sn),S为金额，n为面额数。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp,max);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(int j = 0;j < coins.length;j ++){
                if(coins[j] <= i){
                    dp[i] = Math.min(dp[i],dp[i -coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

### [470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/)

题解：用乘法来构造，加法构造的不是等概率出现的数。思路如下：

```
(rand7()−1) ∗ 7 + rand7()
```

利用上述公式可以等概率生成1-49范围的数字，取值num <= 10的时候，返回，但这样舍弃了39个数字，取的数字占比太低，效率太低；

如果取1-40的数字来生成这样占比高些，效率进一步提高，num <= 40时，返回 1 + num % 10；舍弃了9个数字，效率还不太高，进一步优化，

```
(大于40的随机数−40−1) ∗ 7 + rand7()
```

这样我们可以得到 1−63 之间的随机数，只要舍弃61-63之间的 3 个数即可，那对于这 3 个舍弃的，还可以再来一轮：

```
(大于60的随机数 - 60 - 1) * 7 + rand7()
```

这样我们可以得到 1−21 之间的随机数，只要舍弃 21这1 个数即可。这样走的循环次数大大减少。

```java
class Solution extends SolBase {
    public int rand10() {
        while(true){
            int num = (rand7() - 1) * 7 + rand7();
            // 取1-40之间的数
            if(num <= 40){
                return 1 + num % 10;
            }
            // 如果上一步num在41-49之间，利用如下可以得到1-63之间的数
            num = (num - 41) * 7 + rand7();
            // 取1-60之间的数字
            if(num <= 60){
                return 1 + num % 10;
            }
            // 如果上一步num在61-63之间，利用如下可以得到1-21之间的数
            num = (num - 61) * 7 + rand7();
            // 取1-20之间的数字
            if(num <= 20){
                return 1 + num % 10;
            }
        }
    }
}
```



### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

题解：快慢指针找到中点，然后根据中点反转后半部分链表，然后比较是否是回文链表。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null){
            return false;
        }
        ListNode dummy = new ListNode(0,head);
        ListNode fast = dummy;
        ListNode slow = dummy;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode mid = slow.next;
        slow.next = null;
        // 反转链表
        ListNode reverseHead = reverse(mid);
        while(head != null && reverseHead != null){
            if(head.val != reverseHead.val){
                return false;
            }
            head = head.next;
            reverseHead = reverseHead.next;
        }
        return true;

    }
      private static ListNode reverse(ListNode node){
         ListNode cur = node;
         ListNode prev = null;
         while(cur != null){
             ListNode next = cur.next;
             cur.next = prev;
             prev = cur;
             cur = next;
         }
         return prev;
    }
}
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

题解：回溯法。`dfs(target,combine,idx)` 表示当前在candidates 数组的第idx 位，还剩 target 要组合，已经组合的列表为 combine。递归的终止条件为 `target ≤ 0` 或者 candidates 数组被全部用完。那么在当前的函数中，每次我们可以选择跳过不用第idx 个数，即执行 `dfs(target,combine,idx+1)`。也可以选择使用第idx 个数，即执行`dfs(target−candidates[idx],combine,idx)`，注意到每个数字可以被无限制重复选取，因此搜索的下标仍为idx。

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> combine = new ArrayList<>();
        dfs(candidates,target,combine,ans,0);
        return ans;
    }
    private void dfs(int[] candidates,int target,List<Integer> combine, List<List<Integer>> ans ,int idx){
        if(idx == candidates.length){
            return;
        }
        if(target == 0){
            ans.add(new ArrayList<>(combine));
            return;
        }
        // 不取 idx
        dfs(candidates,target,combine,ans,idx + 1);
        // 取idx
        if(target - candidates[idx] >= 0){
            combine.add(candidates[idx]);
            // 每个数字可以被无限重取，所以仍为idx
            dfs(candidates,target - candidates[idx],combine,ans,idx);
            // 回溯撤回
            combine.remove(combine.size() - 1);
        }
    }
}
```

### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

题解：动态规划。创建 m+1 行 n+1 列的二维数组 dp，其中`dp[i][j] `表示`text1[0:i] `和text2[j:0]的最长公共子数组的长度。1.当其中至少一个数组为空时，公共子序列为空，所以`dp[0][0]`= 0。2.当新出现一个公共数字时，`dp[i][j] = dp[i -1][j -1] + 1;`.没有公共数字时，`dp[i][j] = 0`.

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int[][] dp = new int[m + 1][n + 1];
        int ans = 0;
        for(int i = 1;i <= m ;i++){
            for(int j = 1; j <= n ;j++){
                if(nums1[i -1] == nums2[j -1]){
                    dp[i][j] = dp[i -1][j -1] + 1;
                } 
                ans = Math.max(ans,dp[i][j]);
            }
        }
        return ans;
    }
}
```

还可用滑动窗口，即：把两数组num1、num2相同元素对齐比较,对齐方式有两种，num1不变，num2首元素与num1中某个元素对齐；或者num2不变，num1首元素与num1中某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

题解：1.原地旋转90^。^，由于矩阵中的行列从 0 开始计数，因此对于矩阵中的元素`matrix[row][col]`，在旋转后，它的新位置为 

matrix ~new~`[col][n−row−1]`。推导出整个旋转的元素交换过程：

```
 temp = matrix[row][col]
 matrix[row][col] = matrix[n-col-1][row]
 matrix[n-col-1][row] = matrix[n-row-1][n-col-1]
 matrix[n-row-1][n-col-1] = matrix[col][n-row-1]
 matrix[col][n-row-1] = temp
```

当 n 为偶数时，我们需要枚举 n^2^ / 4 = (n/2)×(n/2) 个位置，可以将该图形分为四块.

当 n 为奇数时，由于中心的位置经过旋转后位置不变，我们需要枚举 (n^2^-1) / 4 =  (n−1)/2)×((n+1)/2) 个位置，需要换一种划分的方式.

综上可以统一为：= (n/2) * ((n +1)/2),因为是向下取整，结果一样。

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for(int i = 0;i < n/2;i++){
            for(int j = 0;j < (n + 1) /2;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = temp;
            }
        }
    }
}
```

2.先水平轴上下翻转，然后根据主对角线翻转。比上面方法更简单。

```
matrix[row][col] ==>>水平轴翻转 matrix[n-row-1][col]
```

 

```
matrix[row][col] ==>>主对角线翻转 matrix[col][row]
```

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平轴，列的上下翻转
        for(int i = 0;i < n/2;i++){
            for(int j = 0;j < n;j++){
                int temp = matrix[n-i-1][j];
                matrix[n-i-1][j] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
        // 主对角线翻转
        for(int i = 0;i < n ;i++){
            for(int j = 0;j < i;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

题解：二分法。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
       int n = nums.length;
        int start = 0,end = n -1;
        while(start <= end && (nums[start] < target || nums[end] > target)){
            int mid = start + ((end - start) >> 1);
            if(nums[mid] > target){
                end = mid -1 < 0 ? 0 : mid -1;
            } else if(nums[mid] < target){
                start = mid + 1 > n -1 ? n -1 : mid + 1;
            } else {

            }
            if(nums[start] < target){
                start++;
            }
            if(nums[end] > target){
                end--;
            }
        }
        return end - start >= 0 ? new int[]{start,end} :new int[] {-1,-1};
    }
}
```

也可以利用二分法分别查找左右端点。查找数组中第一个大于等于target的下标，为左端点，查找大于target的第一个数的下标，然后减一是右端点。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIndex = binarySearch(nums,target,true);
        int rightIndex = binarySearch(nums,target,false) - 1;
        if(leftIndex <= rightIndex && rightIndex < nums.length && nums[leftIndex] == target && nums[rightIndex] == target){
            return new int[]{leftIndex,rightIndex};
        }
        return new int[] {-1,-1};
    }
    private int binarySearch(int[] nums, int target,boolean lower){
        int left = 0,right = nums.length - 1,ans = nums.length;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] > target || (lower && nums[mid] >= target)){
                right = mid -1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```

### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

题解：1.用hashMap统计每个元素出现的次数，然后取出出现次数最大的，但不是最优解。

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> countMap = count(nums);
        Map.Entry<Integer, Integer> ansMapEntry = null;
        for (Map.Entry<Integer, Integer> countMapEntry : countMap.entrySet()) {
            if (ansMapEntry == null || countMapEntry.getValue() > ansMapEntry.getValue()) {
                ansMapEntry = countMapEntry;
            }
        }
        return ansMapEntry.getKey();
    }

    private Map<Integer, Integer> count(int[] nums) {
        Map<Integer, Integer> ans = new HashMap<>();
        for (int num : nums) {
            ans.put(num, ans.getOrDefault(num,0) + 1);
        }
        return ans;
    }
}
```

2.Boyer-Moore 投票算法。如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

算法步骤：

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；如果 x 与 candidate 不等，那么计数器 count 的值减少 1。在遍历完成后，candidate 即为整个数组的众数。

```java
class Solution {
    public int majorityElement(int[] nums) {
       Integer candidate = null;
       int count = 0;
       for(int num : nums){
           if(count == 0){
               candidate = num;
           }
           count+= candidate == num ? 1 : -1;
       }
       return candidate;

    }
}
```

### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

题解；深度优先遍历。一个一个分支的递归，当到叶子结点刚好和同targetSum值相等，则返回true,否则返回false。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        } else if(root.left == null && root.right == null){
            return targetSum == root.val;
        } 
        // left right 递归
        return hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val);
    }
}
```

### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

题解：动态规划。我们用`dp(i,j)` 表示以 `(i,j)` 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 `dp(i,j)` 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。

状态转移方程：`dp(i,j) = min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1)) +1`

如果当前位置`(i,j)`的值为0，则不可能在由1组成的正方形中，`dp(i,j) = 0`；如果值为1，则`dp(i,j)` 的值由其上方、左方和左上方的三个相邻位置的 *dp* 值决定；如果 i 和 j 中至少有一个为 0，则以位置 `(i,j)` 为右下角的最大正方形的边长只能是 1，因此 `dp(i,j)=1`。

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, columns = matrix[0].length;
        int maxWidth = 0;
        int[][] dp = new int[rows][columns];
        for(int i = 0;i < rows;i++){
            for(int j = 0 ;j < columns;j++){
                if(matrix[i][j] == '1'){
                    if(i == 0 || j == 0){
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;
                    }
                    
                }  
                maxWidth = Math.max(maxWidth,dp[i][j]);
            }
        }
        return maxWidth * maxWidth;
    }
}
```

### [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

题解：横向扫描。先取出第一个字符串作为比较模版，然后一个一个字符串遍历，和第一个字符串对比，对比后两字符串公共前缀返回，返回的字符串和继续迭代的字符串对比，一值遍历结束。

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 0){
            return "";
        }
        String ans = strs[0];
        for(int i = 1; i < strs.length ; i++){
            ans = getSameStr(ans,strs[i]);
            if(ans.length() == 0){
                break;
            }
        }
        return ans;
    }
    private String getSameStr(String first,String second){
        int n = Math.min(first.length(),second.length());
        int index = 0;
        for(int i = 0;i < n ; i ++){
            if(first.charAt(i) == second.charAt(i)){
                index++;
            } else {
                break;
            }
        }
        return first.substring(0,index);
    }
}
```

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

题解：动态规划。dp数组来保存走到每一步的路径数。因为每次只能向下或者向右移动一步，所以先计算出第一行和第一列的路径(第一行和第一列的每个位置到达路径都是1)，然后再计算第一行和第一列以外的位置。根据题意推导可知 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。

```java
class Solution {
    public int uniquePaths(int m, int n) {

        int[][] dp = new int[m][n];
        for(int i = 0; i < m;i++){
            dp[i][0] = 1 ;
        }
        for(int j = 0;j < n ;j++){
            dp[0][j] = 1;
        }
        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

2.组合数学。从左上角到右下角的过程中，我们需要移动 m+n−2 次，其中有 m−1 次向下移动，n−1 次向右移动。因此路径的总数，就等于从 m+n−2 次移动中选择 m−1 次向下移动的方案数，即组合数：

```
(m+n−2)(m+n−3)⋯n/(m−1)! = (m+n−2)!/(m−1)!(n−1)!
```

时间复杂度O(m).空间复杂度O(1).

```java
class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for(int x = m,y = 1; y < n;x++,y++){
          	// (m+n−2)(m+n−3)⋯n/(m−1)! （m和n交换不影响结果，使得m≤n时，时间复杂度最小，O(min(m,n))）如下即为：
          	// m*(m+1)...(m+n-2)/1*2*...(n-1)
            ans = ans * x / y;
        }
        return (int)ans;
    }
}
```

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

题解：用hashSet。先把数字放到hashSet 中，然后取遍历数组中的每个数x，遍历的同时去和hashSet中对比是否含有x+1（这里利用了hashSet查看其实中否含有一个数，时间复杂度为O(1),从而不需要排序），还有如果已经有连续的x,x+1,x+2.....序列，那么从x+1，或者从x+y处开始匹配，结果肯定不会优于枚举x为起点的答案。由于我们要枚举的数x在数组中不能含有x-1前驱，所以要判断hashSet中是否含有x-1的数就可以了，有x-1，不进行比较。

```java
class Solution {
   public int longestConsecutive(int[] nums) {
       HashSet<Integer> compareSet = new HashSet<>();
        // 放到hashSet中
        for (int num : nums) {
            compareSet.add(num);
        }
        // 然后对比
       int ans = 0;
        for (int num : compareSet) {
            if (!compareSet.contains(num - 1)) {
                int currentNum = num;
                int currentAns = 1;
                while (compareSet.contains(currentNum + 1)) {
                    currentNum+=1;
                    currentAns+=1;
                }
                ans = Math.max(ans, currentAns);
            }

        }
        return ans;
    }
}
```

### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

题解：二分查找。如果`nums[i]<nums[i+1`]，我们知道位置 i+1 以及其右侧的位置中一定有一个峰值，因此我们可以设计出如下的一个算法：

对于当前可行的下标范围 `[l,r]`，我们随机一个下标 i；

1.如果下标 i 是峰值，我们返回 i 作为答案；

2.如果`nums[i]<nums[i+1]`，那么我们抛弃 `[l,i]` 的范围，在剩余 `[i+1, r]`的范围内继续随机选取下标；

3.如果`nums[i]>nums[i+1]`，那么我们抛弃 `[i, r]` 的范围，在剩余 `[l, i-1]` 的范围内继续随机选取下标。

```java
class Solution {
    public int findPeakElement(int[] nums) {

        int left = 0,right = nums.length -1;
        while(left <= right){
            int mid = left + ((right -left) >> 1);
            if(compare(nums,mid -1 ,mid) > 0 && compare(nums,mid,mid + 1 ) < 0){
                return mid;
            } else if(compare(nums,mid,mid + 1 ) > 0){
                left = mid + 1;
            } else{
                right = mid - 1;
            }
        }
        return left;
    }

    private  int compare(int[] nums, int idx1, int idx2) {
        // nums[idx2] > nums[idx1] 返回 1 ，相等返回 0 ，小于返回 -1
        idx1 = idx1 < 0 ? 0 : idx1;
        idx2 = idx2 >= nums.length ? nums.length  -1 : idx2;
        int ans = 0;
        if (nums[idx1] < nums[idx2]) {
            ans = 1;
        } else if (nums[idx1] > nums[idx2]) {
            ans = -1;
        }
        return ans;
    }
}
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

题解：二分查找。由于每行的元素从左到右升序排列，每列的元素从上到下升序排列。所以我们分行使用二分查找。时间复杂度`O(mlog n)`

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int[] nums : matrix){
            boolean ans =  searchNum(nums,target);
            if(ans){
                return true;
            }
        }
        return false;
    }
    private boolean searchNum(int[] nums,int target){
        int left = 0,right = nums.length -1;
        while(left <= right){
            int mid = left + ((right -left) >> 1);
            if(nums[mid] == target){
                return true;
            } else if(nums[mid] > target){
                right = mid -1;
            } else {
                left = mid + 1;
            }
        }
        return false;
    }
}
```

2.Z 字形查找

我们可以从矩阵 matrix 的右上角 (0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置 (x,y)，那么我们希望在以matrix 的左下角为左下角、以 (x, y) 为右上角的矩阵中进行搜索，即行的范围为 `[x, m - 1]`，列的范围为 `[0, y]`：

如果 `matrix[x,y]=target`，说明搜索完成；

如果 `matrix[x,y]>target`，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 y 列的元素都是严格大target 的，因此我们可以将它们全部忽略，即将 y 减少 1；

如果 `matrix[x,y]<target`，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 x 行的元素都是严格小于target 的，因此我们可以将它们全部忽略，即将 x 增加 1。

在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在target。时间复杂度：O(m + n)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length,n = matrix[0].length;
        int x = 0,y = n -1;
        while(x < m && y >= 0){
            if(matrix[x][y] == target){
                return true;
            } else if(matrix[x][y] > target){
                y--;
            } else {
                x++;
            }
        }
        
        return false;
    }
}
```

### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

题解：二分查找。观察发现，当区间中间值比区间最后一个值大时，可以舍弃前半部分。同时数组中不存在重复元素，区间中间值不比区间最后一个值大时，区间right可取mid，只要区间长度不为1，中间值就不会和区间最后一个值相等，相等的话说明可以结束查找了。

```
 // 最小值在数组中间，发现特点，当前一个循环数组来看，最小值总是处在波谷位置
            4,5,6,7,0,1,2
            2,4,5,6,7,0,1
            1,2,4,5,6,7,0
            0,1,2,4,5,6,7
            7,0,1,2,4,5,6
            6,7,0,1,2,4,5
            5,6,7,0,1,2,4
```



```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0,right = nums.length -1;
        while(left < right){// 不能等于，等于的时候说明已经可以结束循环了
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > nums[right]){
                left = mid + 1;
            } else {
                // 此处不能是mid - 1，不然会漏掉一个元素 
                right = mid;
            }
        }
        // 因为left取的是mid + 1,  
        return nums[left];
    }
}
```

### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

题解：深度优先搜索。就是遍历每个元素（遍历值为1的元素），然后走到每个元素的时候以每个元素为点，递归向左右上下访问，如果对应元素值为1则加上，然后为了重复访问，把刚刚访问过的元素改为0，同时别越界。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length,n = grid[0].length;
        int maxArea = 0;
        for(int i = 0;i < m ; i++){
            for(int j = 0; j < n;j++){
                if(grid[i][j] == 1){
                    maxArea = Math.max(maxArea,getArea(grid,i,j));
                }
            }
        }
        return maxArea;
    }

    private int getArea(int[][] grid,int i,int j){
        if(i < 0 || i > grid.length -1 || j < 0 || j > grid[0].length -1 || grid[i][j] != 1){
            return 0;
        }
        // 修改为0，避免重复访问
        grid[i][j] = 0;
        // 当前为1，则加1，然后继续访问相邻四个方向
        return 1+ getArea(grid,i,j + 1) + getArea(grid,i,j -1) + getArea(grid,i + 1,j) + getArea(grid,i - 1,j);
    }
}
```

### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

题解：1.用栈。遍历字符串：数字入栈(可能会有连续多个数位)，左括号入栈，字母入栈，遇到右括号开始出栈，把出栈字符拼接成字符串，一直到左括号出栈，一个括号内的字符串拼接完成然后反转拼接的字符串，反转成原括号里的样子，此时取出栈顶数字（此时栈顶一定是数字），然后用括号前的数字和括号内的字母拼成完整的字符串放到栈中，和剩下的部分继续恢复完整的字符串。

```java
class Solution {
    int index = 0;
    public String decodeString(String s) {

        LinkedList<String> stack = new LinkedList<>();

        while (index < s.length()) {
            char cur = s.charAt(index);
            if (Character.isDigit(cur)) {
                // 如果是数字（连续多位）
                stack.addLast(getDigits(s));
            } else if (Character.isLetter(cur) || cur == '[') {
                // 左括号入栈，字母入栈
                stack.addLast(String.valueOf(s.charAt(index++)));
            } else {
                LinkedList<String> sub = new LinkedList<>();
                while (!"[".equals(stack.peekLast())) {
                    sub.add(stack.removeLast());
                }
                // 反转字符串
                Collections.reverse(sub);
                // 弹出[
                stack.removeLast();
                int times = Integer.parseInt(stack.removeLast());
                StringBuilder t = new StringBuilder();
                String temp = getString(sub);
                while (times-- > 0) {
                    t.append(temp);
                }
                // 拼好的字符串放到栈中
                stack.addLast(t.toString());
                // 继续访问s字符串的下一个字符
                index++;
            }
        }
        return getString(stack);
    }

    private String getDigits(String str) {
        StringBuilder stringBuilder = new StringBuilder();
        while (Character.isDigit(str.charAt(index))) {
            stringBuilder.append(str.charAt(index++));
        }
        return stringBuilder.toString();
    }

    private String getString(LinkedList<String> sub) {
        StringBuilder stringBuilder = new StringBuilder();
        for (String s : sub) {
            stringBuilder.append(s);
        }
        return stringBuilder.toString();
    }
}
```

2.递归。从左向右解析字符串：

如果当前位置为数字位，那么后面一定包含一个用方括号表示的字符串，即属于这种情况：k[...]：
		我们可以先解析出一个数字，然后解析到了左括号，递归向下解析后面的内容，遇到对应的右括号就返回，此时我们可以根据解析出		的数字 x 解析出的括号里的字符串 s'构造出一个新的字符串 x * s′；
		我们把 k[...] 解析结束后，再次调用递归函数，解析右括号右边的内容。
如果当前位置是字母位，那么我们直接解析当前这个字母，然后递归向下解析这个字母后面的内容。

```java
class Solution {
    int index = 0;
    public String decodeString(String s) {
        if (index == s.length() || s.charAt(index) == ']') {
            return "";
        }
        String ret = "";
        int time;
        char cur = s.charAt(index);
        // 如果是数字
        if (Character.isDigit(cur)) {
            // 解析数字
            time = getDigit(s);
            // 跳过[
            index++;
            // 递归调用解析后面的字符串
            String str = decodeString(s);
            // 跳过]
            index++;
            // 拼接数字和括号内的字符串
            StringBuilder t = new StringBuilder();
            while (time-- > 0) {
                t.append(str);
            }
            ret += t.toString();
        } else if (Character.isLetter(cur)) {
            ret = String.valueOf(s.charAt(index++));
        }
        // 如果是字符直接拼接字符串
        return ret + decodeString(s);
    }

    private int getDigit(String s) {
        int ans = 0;
        while (index < s.length() && Character.isDigit(s.charAt(index))) {
            ans = ans * 10 + s.charAt(index++) - '0';
        }
        return ans;
    }
}
```

### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

题解：堆排序。快排。归并排序。时间复杂度 O(nlogn)。

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

题解：迭代法。用一个临时节点temp，然后通过这个节点去交换它后面的两个节点位置，交换连接好后，再用temp的next节点去进行下一次循环（temp.next进循环就保存）。

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode temp = dummy;
        while (temp.next != null && temp.next.next != null) {
            ListNode node1 = temp.next;
            ListNode node2 = temp.next.next;
            temp.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            temp = node1;
        }
        return dummy.next;
    }
}
```

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

题解：动态规划。如果只有一间房屋，则偷窃该房屋。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃。

如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 `k (k>2)` 间房屋，有两个选项：

1.偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。

2.不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。

在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。

用 `dp[i]` 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：
`dp[i]=max(dp[i−2]+nums[i],dp[i−1])`

边界条件为：
`dp[0]=nums[0]` 只有一间房屋，则偷窃该房屋
`dp[1]=max(nums[0],nums[1])` 只有两间房屋，选择其中金额较高的房屋进行偷窃

最终的答案即为 `dp[n−1]`，其中 n 是数组的长度。

```java
class Solution {
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
      	// 用first、second代替数组
        int first = nums[0],second = Math.max(nums[0],nums[1]);
        for(int i = 2;i < n;i++){
          	// 把当前的i-1保存下来，后面传给first,在下一次循环中就是i-2了
            int temp = second;
            second =  Math.max(first+ nums[i],second);
            // i-2 是first, second是i -1
            first = temp;
        }
        return second;
    }
}
```

### [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

题解：用栈。首先用遍历preSign来表示变量前的符号，对于第一个数字前的符号认为是加号。遇到`前面是加号`的数字直接加入栈中；遇到`前面是减号`的数字，把其相反数存入栈中；遇到`前面是乘/除`号的数字，取出（弹出）栈顶数字和其运算，然后结果放入栈中。字符串遍历结束后，把栈中所有数字相加即可。

```java
class Solution {
    public int calculate(String s) {
          // 数字前符号
        char preSign = '+';
        LinkedList<Integer> stack = new LinkedList<>();
        // 遍历到的数字
        int num = 0,n = s.length();
        for (int i = 0; i < n; i++) {
            // 如果是数字，把数字字符串转化成int
            char cha = s.charAt(i);
            if (Character.isDigit(cha)) {
                num = num * 10 + cha - '0';
            }
            // 如果是运算符号,或者最后一个字符（最后一个字符不可能是运算符，直接加入计算）
            if (!Character.isDigit(cha) && cha != ' ' || i == n - 1) {
                switch (preSign) {
                    case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop() * num);
                        break;
                    default:
                        stack.push(stack.pop() / num);
                }
                // 给下一个数字前的符号赋值
                preSign = cha;
                // num 置空
                num = 0;
            }
        }
        int ans = 0;
        while (!stack.isEmpty()) {
            ans += stack.pop();
        }
        return ans;
    }
}
```

### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

题解：动态规划。我们用 `fmax(i)` 来表示以第 i 个元素结尾的乘积最大子数组的乘积，如果第 i 个元素为正，我们希望`fmax(i - 1)`尽可能的大；如果第 i 个元素为负，我们希望`fmax(i - 1)`尽可能的小；于是我们可以再维护一个 `fmin (i)`，它表示以第 i 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：

​		f~max~(i) = max(a~i~ *  f~max~(i - 1) , a~i~ *  f~min~(i - 1) , a~i~);

​		f~min~(i) = min(a~i~ *  f~max~(i - 1) , a~i~ *  f~min~(i - 1) , a~i~);

```java
class Solution {
    public int maxProduct(int[] nums) {
        int fMax = nums[0],fMin = nums[0],ans = nums[0];
        for(int i = 1;i < nums.length ;i++){
            int mx = fMax,mn = fMin;
            fMax = Math.max(nums[i] * mx, Math.max(nums[i] * mn, nums[i]));
            fMin = Math.min(nums[i] * mx, Math.min(nums[i] * mn, nums[i]));
            ans = Math.max(ans, fMax);
        }
        return ans;
    }
}
```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

题解：动态规划。考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。

定义状态 `dp[i][0]` 表示第 i 天交易完后手里没有股票的最大利润，`dp[i][1]` 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。

考虑 `dp[i][0]` 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 `dp[i−1][0]`，或者前一天结束的时候手里持有一支股票，即 `dp[i−1][1]`，这时候我们要将其卖出，并获得 `prices[i]` 的收益。因此为了收益最大化，我们列出如下的转移方程：
`dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]}`

再来考虑 `dp[i][1]`，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 `dp[i−1][1]`，或者前一天结束时还没有股票，即 `dp[i−1][0]`，这时候我们要将其买入，并减少 `prices[i]` 的收益。可以列出如下的转移方程：
`dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}`

对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 `dp[0][0]=0`，`dp[0][1]=−prices[0]`。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // 用dp0、dp1来代替上述数组
        int dp0 = 0,dp1 = -prices[0];
        for(int i = 1;i < n;i++){
            int temp0 = dp0,temp01 = dp1;
            dp0 = Math.max(temp0,temp01 + prices[i]);
            dp1 = Math.max(temp0 - prices[i],temp01);
        }
        return dp0;
    }
}
```

贪心：这题其实股票购买没有限制，只要第二天价格比第一天高，就可以第一天买，然后第二天卖，一直这么计算利润累加（这里不考虑手续费）。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for(int i = 1;i < prices.length;i++){
            if(prices[i] > prices[i -1]){
                ans+=prices[i] - prices[i -1];
            }
        }
        return ans;
    }
}
```

### [468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address/)

题解：根据IPv4和IPv6的特点分别作处理判断，不符合条件的是“Neither”，符号条件是“IPv4”或者“IPv6”。

```java
class Solution {
    public String validIPAddress(String queryIP) {
        if(queryIP.chars().filter(ch -> ch == '.').count() == 3){
            return validIPv4(queryIP);
        } else if(queryIP.chars().filter(ch -> ch == ':').count() == 7){
            return validIPv6(queryIP);
        } else {
            return "Neither";
        }
    }

    private String validIPv4(String ip){
        String[] nums =  ip.split("\\.",-1);
        for(String num : nums){
            // 长度 1-3
            if(num.length() == 0 || num.length() > 3){
                return "Neither";
            }
            // 不含前导0
            if(num.charAt(0) == '0' && num.length() != 1){
                return "Neither";
            }
            // 都是数字
            for(char c :num.toCharArray()){
                if(!Character.isDigit(c)){
                    return "Neither";
                }
            }
            // 不大于255
            if(Integer.parseInt(num) > 255){
                return "Neither";
            }
        }
        return "IPv4";
    }
    private String validIPv6(String ip){
        String[] nums =  ip.split("\\:",-1);
        String hexdigits = "0123456789abcdefABCDEF";
        for(String num : nums){
            // 长度 4  
             if(num.length() == 0 || num.length() > 4){
                return "Neither";
            } 
            // 16进制数
            for(char c :num.toCharArray()){
                if(hexdigits.indexOf(c) == -1){
                    return "Neither";
                }
            }
            
        }
        return "IPv6";
    }
}
```

### [179. 最大数](https://leetcode.cn/problems/largest-number/)

题解：排序每个数，例如数字42和数字4，比较排序结果442 > 424,这样4就在42的前面，排好序后拼接。

```java
class Solution {
    public String largestNumber(int[] nums) {
        Integer[] numsArr = new Integer[nums.length];
        for (int i = 0; i < nums.length; i++) {
            numsArr[i] = nums[i];
        }
        // 两个数字a、b拼接后ab大还是ba大来排序
        Arrays.sort(numsArr,(x, y) -> {
            int sx = 10,sy = 10;
            // 42 4 -> 424  420 + 4
            while (sx <= x) {
                sx*=10;
            }
            // 42 4 -> 442  400 + 42
            while (sy <= y) {
                sy*=10;
            }
            // 分别求出两个数字的10倍指数来计算，从而腾出给当前数拼接到另外一个数的空间
            return (-sy * x - y + sx * y + x);
        });
        if(numsArr[0] == 0){
            return "0";
        }
        // 然后拼接
        StringBuilder stringBuilder = new StringBuilder();
        for (Integer num : numsArr) {
            stringBuilder.append(num);
        }
        return stringBuilder.toString();
    }
}
```

### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

题解：用异或运算，因为一个数异或它本身位0，0异或一个数结果还是那个数。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int num : nums){
            ans ^=num;
        }
        return ans;
    }
}
```

### [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

题解：1.回溯+hash表。本题因为有随机指针的存在，拷贝节点时，当前节点的随机指针指向的节点可能还没有创建。用回溯的方式让每个节点的拷贝相互独立，对于当前节点，我们先拷贝，然后进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。

步骤：用`哈希表`记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。在实际代码中，我们需要特别判断给定节点为空节点的情况。时间复杂度O(n),空间复杂度O(n).

```java
class Solution {
    Map<Node,Node> map =  new HashMap<>();
    public Node copyRandomList(Node head) {
       if(head == null){
           return null;
       }
       if(!map.containsKey(head)){
           Node newNode = new Node(head.val);
           map.put(head,newNode);
           newNode.next = copyRandomList(head.next);
           newNode.random = copyRandomList(head.random);
       }
        return map.get(head);
    }
}
```

2.迭代+节点拆分。我们首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为A→A′→B→B′
 →C→C′。对于任意一个原节点 S，其拷贝节点 S′即为其后继节点。这样，我们可以直接找到每一个拷贝节点 S′的随机指针应当指向的节点，即为其原节点 S 的随机指针指向的节点 T 的后继节点 T′。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。时间复杂度O(n),空间复杂度O(1).

```java
class Solution {
    public Node copyRandomList(Node head) {
       if(head == null){
           return null;
       }
        // 拷贝next节点
        for(Node node = head;node != null;node = node.next.next){
            Node newNode = new Node(node.val);
            newNode.next = node.next;
            node.next = newNode;
        }
        // 拷贝random节点
         for(Node node = head;node != null;node = node.next.next){
            Node newNode = node.next;
            newNode.random = node.random != null ? node.random.next : null;
        }
        // 把拷贝的节点从原链表上拆下来
        Node newhead = head.next;
         for(Node node = head;node != null;node = node.next){
            Node newNode = node.next;
            node.next = node.next.next;
            newNode.next = newNode.next != null ? newNode.next.next : null;
        }
        return newhead;
    }
}
```

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

题解：滑动窗口。定义两个指针start 和 end 分别表示子数组（滑动窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。  初始状态下，start 和 end 都指向下标 0，sum 的值为 0。  每一轮迭代，将nums[end] 加到 sum，如果 `sum ≥ target`，则更新子数组的最小长度（此时子数组的长度是 `end−start+1`），然后将 `nums[start]` 从sum 中减去并将 start 右移，直到 `sum < target`，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将end 右移。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        if(nums.length == 0){
            return 0;
        }
        int start = 0,end = 0,sum = 0,n = nums.length;
        int minLength = Integer.MAX_VALUE;
        while(end < n){
            sum+=nums[end];
            while(sum >= target){
                minLength = Math.min(minLength,end - start + 1);
                sum-=nums[start++];
            }
            end++;
        }
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

题解：双指针。使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：左指针左边均为非零数；右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

```javascript
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while(right < n){
            if(nums[right] != 0){
              swap(nums,right,left++);
            }
            right++;
        }
    }
    private void swap(int[] nums,int i ,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### [498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

题解：对角线遍历。观察发现， 1.每条对角线上的坐标和是相同的，且从左往右递增，如（左上角算第一条）第一条对角线：（0，0）x+y=0;第二条对角线 ：(1,0),(0,1) x+ y = 1;第三条对角线：(0,2),(1,1),(2,0),x + y =2。  2.每一条对角线都是x或y其中一个从大到小（每次-1），另一个从小到大（每次+1）。    3.初始值：例如这条对角线是 x 从大到小， x 尽量取最大，当初始值超过 x 的上限时，不足的部分加到 y 上面。例如：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1，x 初始值取 1，y 取 0。     4.	确定结束值。例如这一条对角线是 x 从大到小，这一趟结束的判断是， x 减到 0 或者 y 加到上限。例如：2 的坐标(1, 0)，4 的坐标(0, 1)。x 减到 0 为止。    5.这一条对角线是 x 从大到小，那么下一条对角线是 y 从大到小，循环进行。 并且方向相反时，逻辑处理是一样的，除了x，y和他们各自的上限值是相反的。

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        if (mat.length == 0 || mat[0].length == 0) {
            return new int[0];
        }
       int rows = mat.length,columns = mat[0].length;
       int[] ans = new int[rows * columns];
       boolean bxFLag = true;
       int index = 0;
        for (int i = 0; i < rows + columns - 1; i++) {
            // 根据不同的对角线方向，x、y代表的值不同，就是在这里变换的，bxFLag = true x代表x，y代表y；
            // bxFLag = false时，x代表y，y代表x，所以下面相应的坐标也要交换，px、py也相当于交换了
            int px = bxFLag ? rows : columns;
            int py = bxFLag ? columns : rows;

            int x = i < px ? i : px -1;
            int y = i - x;
            while (x >= 0 && y < py) {
                // x、y交换了
                ans[index++] = bxFLag ? mat[x][y] : mat[y][x];
                x--;
                y++;
            }
            // 变换对角线方向
            bxFLag = !bxFLag;
        }
       return ans;
    }
}
```

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

题解：由于二叉搜索树的中序遍历是递增序列，那它的中序遍历的逆序就是递减序列，所以第k大节点，就是中序遍历的逆序的第k个节点。所以中序遍历的逆序遍历，遍历到第k个即是答案。

```java
class Solution {
    int k,res;
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        dfs(root);
        return res;
    }
    private void dfs(TreeNode root){
        if(root == null){
            return;
        }
        dfs(root.right);
        // k ==0 说明遍历结束了
        if(k == 0){
            return;
        }
        // 此时是第k大节点值
        if(--k == 0){
            res =  root.val;
        }
        dfs(root.left);
    }
}
```

### [958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

题解：广度优先搜索。用 `(depth, position)` 元组表示每个节点的“位置”，从根节点开始，每一行从左往右给节点编号：根节点是1，它的左右节点位置2，3。 其实可以发现规律每个节点`v`(位置编号)，其左右子节点编号为`2 * v`和`2 * v + 1`。如果是完全二叉树，他们的编号之间是没有空白的（就是每一行不会有中间缺节点的情况）。会发现广度优先搜索的位置编号是升序排列的。检验编号间是否有空格就可以校验是否是完全二叉树了，其实可以转化为`校验节点数是否和最后一个节点的位置相等`。

```java
class Solution {
    int size = 0,lastPosition = 0;
    public boolean isCompleteTree(TreeNode root) {
        bfs(root,1);
        return size == lastPosition;
    }

    private void bfs(TreeNode root,int index){
        if(root == null){
            return;
        }
        size++;
        lastPosition = Math.max(lastPosition,index);
        bfs(root.left,2 * index);
        bfs(root.right,2 * index + 1);
    }
}
```

### [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)

题解：括号展开 + 栈。由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。

因此，我们考虑使用一个取值为 {−1,+1} 的整数 sign 代表「当前」的符号。根据括号表达式的性质，它的取值：

`1.与字符串中当前位置的运算符有关；`
`2.如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以 − 号开头的括号，则意味着此后的符号都要被「翻转」。`
考虑到第二点，我们需要维护一个栈ops，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。例如，对于字符串 1+2+(3-(4+5))：

扫描到 1+2 时，由于当前位置没有被任何括号所包含，则栈顶元素为初始值+1；
扫描到 1+2+(3 时，当前位置被一个括号所包含，该括号前面的符号为 + 号，因此栈顶元素依然 +1；
扫描到 1+2+(3-(4 时，当前位置被两个括号所包含，分别对应着 + 号和 − 号，由于 + 号和 − 号合并的结果为 − 号，因此栈顶元素变为 −1。
在得到栈 ops 之后，sign 的取值就能够确定了：如果当前遇到了 + 号，则更新 sign←ops.top()；如果遇到了遇到了 − 号，则更新 sign←−ops.top()。然后，每当遇到 ( 时，都要将当前的 sign 取值压入栈中；每当遇到 ) 时，都从栈中弹出一个元素（此时和括号内的符号使用结束）。这样，我们能够在扫描字符串的时候，即时地更新 ops 中的元素。

```java
class Solution {
    public int calculate(String s) {
    LinkedList<Integer> ops = new LinkedList<>();
    int n = s.length(),index = 0,sign = 1;
    ops.push(1);
    int ans = 0;
    while(index < n){
        char cur = s.charAt(index);
        if(cur == ' '){
            index++;
        } else if(cur == '+'){
            sign = ops.peek();
            index++;
        } else if(cur == '-'){
            sign = -ops.peek();
            index++;
        } else if(cur == '('){
            ops.push(sign);
            index++;
        } else if(cur == ')'){
            ops.pop();
            index++;
        } else {
            // 根据符号累加数字
            int num = 0;
            while(index < n && Character.isDigit(s.charAt(index))){
                num = num * 10 + s.charAt(index++) - '0';
            }
            ans+= sign * num;
        }
    }
        return ans;
    }
}
```

### [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)

题解：贪心+单调栈。贪心策略：

给定一个长度为 n 的数字序列 [D~0~D~1~D~2~D~3~…D~n−1~]，从左往右找到第一个位置 `i（i>0）`使得 D~i~< D~i−1~，并删去 D~i−1~ ；如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下的 n-1长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至删除 k 次。暴力的实现复杂度最差会达到 O(nk)（考虑整个数字序列是单调不降的）。

考虑从左往右增量的构造最后的答案。用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过 k 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。(这里用双向队列，不需要反转数字)

因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到：1.栈为空 2.或者新的栈顶元素不大于当前数字 3.或者我们已经删除了 k 位数字

如果删除了 m 个数字且 m<k，需要从序列尾部删除额外的 k−m 个数字。如果最终的数字序列存在前导零，删去前导零。如果最终数字序列为空，返回 0。

```java
class Solution {
    public String removeKdigits(String num, int k) {
        if(num == null){
            return "0";
        }
        LinkedList<Character> queue = new LinkedList<>();
        for(int i = 0; i < num.length(); i++){
            char cur = num.charAt(i);
            // 删除栈顶大于当前数的栈顶元素
            while(!queue.isEmpty() && k > 0 && queue.peekLast() > cur){
                queue.pollLast();
                k--;
            }
            queue.offerLast(cur);
        }
        // 删后，还没删到k个，继续删栈顶元素（数字后面开始删）
        for(int i = 0; i < k; i++){
            queue.pollLast();
        }
        // 从栈中组装会最小数字，如果有前导0，跳过，不组装它
        StringBuilder str = new StringBuilder();
        // 前导零
        boolean leaderZero = true;
        while(!queue.isEmpty()){
            char cur = queue.pollFirst();
            if(leaderZero && cur == '0'){
                continue;
            }
            leaderZero = false;
            str.append(cur);
        }
        return str.length() == 0 ? "0" : str.toString();
    }
}
```

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

题解：前缀和 + 哈希表。定义`pre[i]` 为 `[0..i]`里索引<= i 的数的和。那么`pre[i]=pre[i−1]+nums[i]`。 `[j..i]` 这个子数组和为 k。

用k替换`nums[i]`可以推导出`pre[i−1] = pre[i] - k`。所以可以以前缀和`pre[i]`为key，然后`pre[i]`出现的次数为value存入hashMap 中，当出现了`pre[j] = pre[i] - k`时，（`pre[i] - k`作为key从hashMap中获取），子数组count++；最后count即为答案。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        int pre = 0,count = 0;
        for(int i = 0; i < nums.length ; i++){
            pre +=nums[i];
            if(map.containsKey(pre - k)){
                count+= map.get(pre - k);
            }
            if(pre == k){
                // 从0到i累加和刚好为k
                count++;
            }
            map.put(pre,map.getOrDefault(pre,0) + 1);
        }
        return count;
    }
}
```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

题解：动态规划。定义 `dp[i]` 表示字符串 s 前 i 个字符组成的字符串 `s[0..i-1]` 是否能被空格拆分成若干个字典中出现的单词。枚举 `s[0..i-1]` 中的分割点 j ，看 `s[0..j-1]` 组成的字符串 s~1~（默认 j = 0 时 s~1~为空串）和 `s[j..i-1]` 组成的字符串 s~2~  是否都合法，如果两个字符串均合法，那么按照定义 s~1~  和 s~2~ 拼接成的字符串也同样合法。转移方程：

`dp[i] = dp[j] && check(s[j..i−1])`，其中check(s[j..i−1])表示子串s[0..i-1]是否出现在字典中，边界条件`dp[0] = true`表示字符串合法。

用hash表来存放字典，从而实现快速判断。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> wordDictSet = new HashSet<>(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = 0 ; j < i ; j++){
                if(dp[j] && wordDictSet.contains(s.substring(j,i))){
                    dp[i] = true;
                }
            }
        }
        return dp[n];
    }
}
```

### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

题解：动态规划。用 `dp[x]` 表示金额之和等于 xx 的硬币组合数，目标是求`dp[amount]`。动态规划的边界是 dp[0]=1。当`coin ≤ i ≤ amount` ,对于硬币组合 i，如果存在一种硬币组合等于i - coin，那么在 i - coin 组合中加上coin，就可以得到一种金额组合为 i 的硬币组合，所以：

1. dp[0]=1。

2. i 从 coin 到 amount，将`dp[i - coin]`的组合的值加到`dp[i]`（因为dp[i - coin]也是`dp[i]`的硬币组合，只是前面没有统计到）。

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for(int coin : coins){
            for(int i = coin; i <= amount; i++){
                dp[i] += dp[i - coin];
            }
        }
        return dp[amount];
    }
}
```

### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

题解：转化为拓扑排序 + 广度优先搜索。根据拓扑排序的特点，比如课程a、b, a -> b,要修课程b，就要先修课程a，a就是b的入边，b就是a的出边。我们可以先把所有有入边的课程在数组indeg中标记入边数，然后把所有入边数为0的课程`u`放到队列中，然后一次从队列中取出入边为0的课程u，每取出一个课程u，学过的课程visited就+1，然后移除课程u的所有出边（即移除课程u对应的所有出边v移除当前的入边），然后把移除入边后的课程，入边为0的课程v放入队列，如此往复。学过的课程visited和要学的课程数numCourses比较是否相等，即为答案。

```java
class Solution {
    List<List<Integer>> edges;
    int[] indeg;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        // 创建存放numCourses门课程的集合
        for(int i = 0;i < numCourses;i++){
            edges.add(new ArrayList<Integer>());
        }
        indeg = new int[numCourses];
        // 把要学的课程入边对应的出边放入上述集合中
        for(int[] info : prerequisites){
            edges.get(info[1]).add(info[0]);
            // 课程info[0] 的入边 +1
            indeg[info[0]]++;
        }
        LinkedList<Integer> queue = new LinkedList<>();
        // 把入边为 0 的课程放入队列中
        for(int i = 0;i < numCourses;i++){
            if(indeg[i] == 0){
                queue.offer(i);
            }
        }
        // 代表学过的课程
        int visited = 0;
        while(!queue.isEmpty()){
            visited++;
            // 每当学好一门课程，即移除入边u的所有出边
            int u = queue.poll();
            for(int v : edges.get(u)){
                indeg[v]--;
                // 当课程的入边为0时，说明没有必须先修的课程了，可以添加入队列
                if(indeg[v] == 0){
                    queue.offer(v);
                }
            }
        }
        return visited == numCourses;
    }
}
```

### [338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

题解：动态规划-最低有效位。对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是⌊x/2⌋。如果 bits[⌊x/2⌋] 的值已知，则可以得到 bits[x] 的值：

如果 xx 是偶数，则 bits[x]=bits[⌊x/2⌋]]；

如果 xx 是奇数，则  bits[x]=bits[⌊x/2⌋]] +1。

上述两种情况可以合并成：]bits[x] 的值等于 bits[⌊x/2⌋]] 的值加上 x 除以 2 的余数。

即 bits[x] = bits[x>>1] + (x & 1)。 时间复杂度O( N) ,空间复杂度 O( 1).

```java
class Solution {
    public int[] countBits(int n) {
        int[] bits = new int[n +1];
        for(int i = 0;i <= n; i++){
            bits[i] = bits[i >> 1] + (i &1);
        }
        return bits;
    }
}
```

### [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

题解：使用两个hash表+一个变量。 1.先创建一个双向链表的Node节点类，用来存放 key、value、freq(使用频率)、prev、next。   2.然后利用Node类来构建一个双向链表。	3.keyMap这个hash表用来存放 key、Node这一对键值对，freqMap这份额hash表用来存放频率freq、双向链表键值对（双向链表插入的时候采用头插法，因为这样链表头的节点就是最新使用的，链表尾节点是距离现在最久使用的）。	4.get的时候，把node节点迁移到freqMap中freq+1的键对应链表上，node节点中freq +1 (这里采用新建一个节点)。	5.put分为key存在还是不存在，不存在的话，要去判断缓存是否满了，如果满了，要去做对应清理后再添加到freqMap中key为1的链表中，添加到keyMap中；key存在时，keyMap中key对应的节点node的val值覆盖，把freqMap中对应freq的节点迁移到freq + 1键对应的链表上（头插），node的freq + 1。

```java
public class LFUCache {
    // 最小频率
    int minFreq;
    int capacity;
    Map<Integer,Node> keyMap;
    // key 为 频率 freq
    Map<Integer,DoubleLinkedList> freqMap;
    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.minFreq = 0;
        this.keyMap = new HashMap<>();
        this.freqMap = new HashMap<>();
    } 
    public int get(int key) {
        if (capacity == 0) {
            return -1;
        }
        if (!keyMap.containsKey(key)) {
            return -1;
        }
        Node node = keyMap.get(key);
        int val = node.value,freq = node.freq;
        // 删除freqMap中原来的键值对，
        freqMap.get(freq).remove(node);
        // 如果上面移除掉当前节点后，前链表为空,更新minFreq
        if (freqMap.get(freq).size == 0) {
            freqMap.remove(freq);
            if (minFreq == freq) {
                minFreq++;
            }
        }
        // 移动的新位置freq +1，插入到链表头（链表头是链表中最新使用的）
        DoubleLinkedList list = freqMap.getOrDefault(freq + 1, new DoubleLinkedList());
        list.addFirst(new Node(key,val,freq + 1));
        freqMap.put(freq + 1, list);
        // get一次 freq +1，
        keyMap.put(key, freqMap.get(freq + 1).getHead());
        return val;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        // 不包含该键
        if (!keyMap.containsKey(key)) {
            // 缓存已满
            if (keyMap.size() == capacity) {
                // 移除使用频率最低的链表末尾元素
                Node node = freqMap.get(minFreq).getTail();
                keyMap.remove(node.key);
                freqMap.get(minFreq).remove(node);
                // 移除后，如果使用频率最低的链表为空，移除链表对应的键值对
                if (freqMap.get(minFreq).size == 0) {
                    freqMap.remove(minFreq);
                }
            }
            DoubleLinkedList list = freqMap.getOrDefault(1, new DoubleLinkedList());
            list.addFirst(new Node(key,value,1));
            freqMap.put(1, list);
            keyMap.put(key, freqMap.get(1).getHead());
            minFreq = 1;
        } else {
            // 包含该键
            Node node = keyMap.get(key);
            int freq = node.freq;
            // 删除freqMap中原来的键值对，
            freqMap.get(freq).remove(node);
            // 如果上面移除掉当前节点后，前链表为空,更新minFreq
            if (freqMap.get(freq).size == 0) {
                freqMap.remove(freq);
                if (minFreq == freq) {
                    minFreq++;
                }
            }
            // 移动的新位置freq +1，插入到链表头（链表头是链表中最新使用的）
            DoubleLinkedList list = freqMap.getOrDefault(freq + 1, new DoubleLinkedList());
            list.addFirst(new Node(key,value,freq + 1));
            freqMap.put(freq + 1, list);
            keyMap.put(key, freqMap.get(freq + 1).getHead());
        }
    }

    class Node{
        int key,value;
        // 使用频率
        int freq;
        Node prev,next;
        public Node() {
            this(-1, -1, 0);
        }
        public Node(int key, int value, int freq) {
            this.key = key;
            this.value = value;
            this.freq = freq;
        }
    }
    // 双向链表
    class DoubleLinkedList{
        Node dummyHead,dummyTail;
        int size;
        public DoubleLinkedList() {
            dummyHead = new Node();
            dummyTail = new Node();
            dummyHead.next = dummyTail;
            dummyTail.prev = dummyHead;
            size = 0;
        }
        public void addFirst(Node node) {
            Node prevHead = dummyHead.next;
            node.prev = dummyHead;
            dummyHead.next = node;
            node.next = prevHead;
            prevHead.prev = node;
            size++;
        }
        public void remove(Node node) {
            Node prev = node.prev;
            Node next = node.next;
            prev.next = next;
            next.prev = prev;
            size--;
        }
        public Node getHead() {
            return dummyHead.next;
        }
        public Node getTail() {
            return dummyTail.prev;
        }

    }
}
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

题解：回溯法。先把数字对应的字母放在map中，组成映射关系，然后根据输入的数字digits，然后根据每一位数字去通过回溯取一个当前数字对应的字母（每次取一个），再去取下一个数字对应的字母。

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return combinations;
        }
        Map<Character,String> letterMap = new HashMap<>();
        letterMap.put('2',"abc");
        letterMap.put('3',"def");
        letterMap.put('4',"ghi");
        letterMap.put('5',"jkl");
        letterMap.put('6',"mno");
        letterMap.put('7',"pqrs");
        letterMap.put('8',"tuv");
        letterMap.put('9',"wxyz");
        backtrack(digits,letterMap,combinations,0,new StringBuilder());
        return combinations;
    }

    private void backtrack(String digits,Map<Character,String> letterMap,List<String> combinations,int index,  StringBuilder combination){
        if(index == digits.length()){
            combinations.add(combination.toString());
            return;
        }
        char digit = digits.charAt(index);
        String letters = letterMap.get(digit);
        for(int i = 0; i < letters.length();i++){
            // 如果取当前字母
            combination.append(letters.charAt(i));
            // 再去取index + 1位置的字母
            backtrack(digits,letterMap,combinations,index + 1,combination);
            // 换当前数字对应的其他字母
            combination.deleteCharAt(index);
        }
    }
}
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

题解1：hash表 + 字符串排序。因为相同字母组成的字符串，排序后的结果相同，因此可以排序后放到同一个list中，由此可以组成 Map<String,List<String>> ,key是排序后的字符串，value是前面说到的的list，map转成lsit即为答案。时间复杂度：O(nklogk)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // map
        HashMap<String,List<String>> map = new HashMap<String,List<String>>();
        // 迭代的时候把单词按字母排序，一样的放在一个键值对中
        for(String str : strs){
           char[] chars = str.toCharArray();
           Arrays.sort(chars);
           String key = new String(chars);
           List<String> list = map.getOrDefault(key,new ArrayList<String>());
           list.add(str);
           map.put(key,list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```
题解2：hash表 + 字母计数。和题解1相同使用map，就是这里面的key，用一个长度为26的数组记录每个字母出现次数，然后根据出现次数大于0的`字母+出现次数`拼接,这样由相同字母组成的字符串的key也是相同的。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // map
        HashMap<String,List<String>> map = new HashMap<String,List<String>>();
        // 迭代的时候把单词按字母排序，一样的放在一个键值对中
        for(String str : strs){
            int[] counts = new int[26];
            // 根据小写字母，把字符串中所有出现的字母在长度为26的数组中记录对应出现次数
            for(int i = 0;i < str.length();i++){
                counts[str.charAt(i) - 'a']++;
            }
            // 然后把数组从前往后遍历，把出现次数大于0的字母取出，拼成字符串，这样所有由相同字母拼成的字符串会拼成相同的key
            // 本质上其实还是排序
            StringBuilder strKey = new StringBuilder();
            for(int i = 0;i < 26;i++){
                if(counts[i] != 0){
                    strKey.append((char)('a' + i));// 此处只是append一个字母
                    strKey.append(counts[i]);// 再append出现次数保证同一个字母出现n次只用append2次，且唯一
                }
            }
           String key = strKey.toString();
           List<String> list = map.getOrDefault(key,new ArrayList<String>());
           list.add(str);
           map.put(key,list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

题解：贪心算法。对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 `x + nums[x]`，这个值大于等于 y，即 `x + nums[x] ≥ y`，那么位置 y 也可以到达。

换句话说，对于每一个可以到达的位置 x，它使得 `x+1,x+2,⋯,x+nums[x]` 这些连续的位置都可以到达。这样以来，我们依次遍历数组中的每一个位置，并实时维护最远可以到达的位置 farthestSite，如果farthestSite >= n -1,则可到达，如果遍历到数组最后不满足条件则不可达。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int farthestSite = 0;
        int n = nums.length;
        for(int i = 0;i < n;i++){
            if( i <= farthestSite){
                farthestSite = Math.max(farthestSite,i + nums[i]);
                if(farthestSite >= n -1){
                    return true;
                }
            }
        }
        return false;
    }
}
```

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

题解：双指针。荷兰国旗问题，分别用两个双指针，一个q从从左向右移动，一个p从右向左移动，数组当前遍历到的位置i。1.如果找到了 0，将其与 nums[q] 进行交换，并将q向后移动一个位置；2.如果找到了 2，那么将其与nums[p ] 进行交换，并将 p 向前移动一个位置。由于遍历指针i一直在往前走，所以情况2，交换后的数字还有可能是2，所以需要继续交换（不交换的话，就遗漏了），直到`num[i]`不为2。

```java
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int q = 0,p = n -1;
        int index = 0;
        while(index <= p){
            // 交换后,index位置上可能还是2，所以一直交换，直到不为2
            while(index <= p && nums[index] == 2){
                swap(nums,index,p--);
            }
            if(nums[index] == 0){
                swap(nums,index,q++);
            } 
            index++;
        }
    }
    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

题解：回溯法。设函数 `check(i,j,k)` 表示判断以网格的 `(i, j)` 位置出发，能否搜索到单词 `word[k..]`，其中 word[k..] 表示字符串 word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。函数 `check(i,j,k)` 的执行步骤如下：

1. 如果 `board[i][j] != s[k]`，当前字符不匹配，直接返回 false。
2.如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。
3.否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串 word[k+1..]，则返回 true，否则返回 false。
这样，我们对每一个位置 `(i,j)` 都调用函数 `check(i,j,0)` 进行检查：只要有一处返回 true，就说明网格中能够找到相应的单词，否则说明不能找到。

为了防止重复遍历相同的位置，需要额外维护一个与 board 等大的 visited 数组，用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已经被访问的位置。时间复杂度 O(MN * 3^L^)，m，n为网络长、宽，L为word长度。

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length, columns = board[0].length;
        boolean[][] visited = new boolean[rows][columns];
        for(int i = 0; i < rows; i++){
            for(int j = 0;j < columns;j++){
                boolean flag = check(board,i,j,word,visited,0);
                if(flag){
                    return true;
                }
            }
        }
        return false;
    }
    private boolean check(char[][] board,int i, int j,String word,boolean[][] visited,int k){
        if(board[i][j] != word.charAt(k)){
            return false;
        } else if(k == word.length() -1){
            // 如果word遍历到末尾，且board[i][j] == word.charAt(k) 返回ture
            return true;
        }
        visited[i][j] = true;
        boolean result = false;
        // 每个位置向他的四个方向移动
        if(isOutOfBounds(board,i+1,j) && !visited[i+1][j] && check(board,i + 1,j,word,visited,k + 1)
            || isOutOfBounds(board,i-1,j) && !visited[i-1][j] && check(board,i - 1,j,word,visited,k + 1)
            || isOutOfBounds(board,i,j+1) && !visited[i][j+1] && check(board,i,j + 1,word,visited,k + 1)
            || isOutOfBounds(board,i,j-1) && !visited[i][j-1] && check(board,i,j -1,word,visited,k + 1)){
            result = true;
        }
        // 回撤
        visited[i][j] = false;
        return result;
    }
    private boolean isOutOfBounds(char[][] board,int i,int j){
        int rows = board.length, columns = board[0].length;
        if(i >=0 && i < rows && j >= 0 && j < columns){
            return true;
        }
        return false;
    }

}
```

### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

题解：用两个数组`L[]、R[]`分别保存数字`nums[i]`左边的数的乘积，和`nums[i]`右边的数的乘积，然后再把左边的 i 左边的乘积和i 右边的乘积相乘即为答案。`L[i] = L[i -1] * nums[i -1], R[i] = R[i + 1] * nums[i + 1]`。做到空间复杂度O(1)，因为答案`ans[]`数组不占用空间复杂度，所以把左乘积放到`ans[]`中，然后从数组最右边开始遍历数组，用一个变量right来保存i右边的乘积，然后再把right和`ans[]`数组中 `ans[i]`（即数组nums中 i 左边的数的乘积）相乘即可。

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        // 因为0索引位置左边没有值了，所以为1
        ans[0] = 1;
        // nums[i] 乘以 他左边的数字相乘的积
        for(int i = 1; i < n ;i++){
            ans[i] = ans[i - 1] * nums[i -1];
        }
        // 因为 n-1索引右边没有值了， 所以为1
        int right = 1;
        // nums[i] 乘以 他右边的数字相乘的积
        for(int i = n - 1; i >= 0; i--){
            ans[i] = ans[i] * right;
            // nums[i -1]右边的数的乘积
            right *= nums[i];
        }
        return ans;
    }
}
```

### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

题解：1.动态规划。给定一个有序序列1....n构建二叉搜索树，遍历每个数 i，将该数字作为根，1....(i -1)作为左子树，(i + 1)...n作为左子树，然后按照同样的方式构建左右子树。其实会发现长度为n， 以 i 为根的二叉搜索树的种数为：左子树种类数 * 右子树种类数；而 i 可能为1....（n）所以把这些都加起来就是答案。

```java
class Solution {
    public int numTrees(int n) {
        int[] ans = new int[n + 1];
        ans[0] = 1;
        ans[1] = 1;
        for(int i = 2; i <=n ;i++){
            for(int j = 1 ;j <=i ;j++){
                ans[i] += ans[j -1] * ans[i -j];
            }
        }
        return ans[n];
    }
}
```

2.数学。方法1中的推导在数学上叫卡塔兰数。可以推导出 ：`ans[ i ]  = ans[i - 1] * 2 * （2 * n + 1）/ (n + 2)`,ans可以用一个遍历c来代替。

```java
class Solution {
    public int numTrees(int n) {
        long c = 1;
        for(int i = 0; i < n ;i++){
           c = c * 2 * (2 * i + 1) / (i + 2);
        }
        return (int)c;
    }
}
```

### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

题解：1.利用前序遍历。利用栈，访问到一个节点时，先把右节点放入栈中，然后再把左节点放入栈中，然后把当前节点设为prev前驱节点，然后弹出栈顶元素，把栈顶元素接在prev右指针上，把左指针置为null，重复上面操作。

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null){
            return;
        }
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        stack.push(root);
        TreeNode prev = null;
        while(!stack.isEmpty()){
            // 栈顶元素作为当前元素
            TreeNode curr = stack.pop();
            // 如果前驱节点不为空，则把当前节点接在右指针下
            if(prev != null){
                prev.left = null;
                prev.right = curr;
            }
            // 先把右子节点压入栈，防止先取左子节点后，右节点丢失
            if(curr.right != null){
                stack.push(curr.right);
            }
            if(curr.left != null){
                stack.push(curr.left);
            }
            prev = curr;
        }
    }
}
```

2.寻找右节点的前驱节点。访问到一个节点时，右节点的前驱节点，其实会发现，是左子树的最右节点，找到这个前驱节点，然后把右子树连在前驱节点上，把左子树连在当前节点的右指针上，左指针置空，如此往复操作。

```java
class Solution {
    public void flatten(TreeNode root) {
        TreeNode curr = root;
        while(curr != null){
            // 找到当前节点右子节点的前驱节点
            if(curr.left != null){
                TreeNode next = curr.left;
                TreeNode pre = next;
                // 找到当前节点左子树的最右节点，即为当前节点右子树的前驱节点
                while(pre.right != null){
                    pre = pre.right;
                }
                pre.right = curr.right;
                curr.right = next;
                curr.left = null;
            }
            curr = curr.right;
        }
    }
}
```

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

题解：单调栈。对于每一个遍历到的数组索引 i ，我们要分别找到i对应的数的 `左边离它最近的小于他的数（保存对应的索引）`和 `右边离它最近的小于它的数 （保存对应的索引）`。然后这样我们就能计算每个遍历到的数索引 i 对应的最大矩形，然后在这所有的最大矩形中取最大值。

i对应的数的左右边比它小的最近的数，用单调递增栈去求，从0...到i ....n-1遍历，当栈顶元素大于等于 i对应的值，弹出，直到栈顶元素小于i对应的数，然后把栈顶元素赋给 i 左边最近比他小的数对应数组中（如果此时栈空了，还没找到这个数，把 i 左边最近比他小的数 设为-1 （因为求面积求的是两索引间的矩形面积，而不包括左右边的索引，所以没有影响））。同时在栈顶元素j 对应的数比 i对应的数大或相等时，其实 i 对应的数是j对应的数的右边比它小或者等于的最近的数，但是我们需要找的小于的数，所以我们和前面 -1一样，把right所有值先置为n ，再去计算，这样不会少计算一个右边的数。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        Deque<Integer> stack = new LinkedList<Integer>();
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(right, n);
        for(int i = 0; i < n; i++){
            while(!stack.isEmpty() && heights[stack.peek()] >= heights[i]){
                right[stack.pop()] = i;
            }
            left[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }
        int ans = 0;
        // 计算面积
        for(int i = 0; i < n ; i++){
            ans = Math.max(ans,(right[i] - left[i] - 1) * heights[i]);
        }
        return ans;
    }
}
```

### [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

题解：单调栈。可以把矩阵中的每一个一维数组中的每个元素`matrix[i][j]`,左边有多少个连续的1记为`left[i][j]`,然后这些一维数组中连续的1其实是相当于84题的柱状图，然后我们用单调递增栈去找到每个连续1`left[i][j]`的柱状图上下离它最近的比他短的两个柱状图`up[i]`和`dowm[i]`,然后 求每个 `up[i]`和`dowm[i]`间的矩形面积（每一列都需要去找到`up[i]`和`dowm[i]`），他们中最大的矩形就是答案。

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length,n = matrix[0].length;
        if(m == 0){
            return 0;
        }
        int[][] left = new int[m][n];
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(matrix[i][j] == '1'){
                    // j == 0的时候默认为1
                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; 
                }
            }
        }
        int ans = 0;
        // 对二维数组的每一列去使用柱状图的方法
        for(int j = 0; j < n; j++){
            int[] up = new int[m];
            int[] dowm = new int[m];
            Deque<Integer> stack = new LinkedList<Integer>();
            // up
            for(int i = 0;i < m ; i++){
                while(!stack.isEmpty() && left[stack.peek()][j] >= left[i][j]){
                    stack.pop();
                }
                up[i] = stack.isEmpty() ? -1 : stack.peek();
                stack.push(i);
            }
            stack.clear();
            // dowm
            for(int i = m -1;i >= 0 ; i--){
                while(!stack.isEmpty() && left[stack.peek()][j] >= left[i][j]){
                    stack.pop();
                }
                dowm[i] = stack.isEmpty() ? m : stack.peek();
                stack.push(i);
            }
            // 计算面积
            for(int i = 0;i < m;i++){
                ans = Math.max(ans,(dowm[i] - up[i] -1) * left[i][j]);
            }
        }
        return ans;
    }
}
```

### [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

题解：动态规划。我们用 `f[i][j]` 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配。在进行状态转移时，我们考虑 p 的第 j 个字符的匹配情况：

1. 如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母，即

`f[i][j] = f[i - 1][j - 1] 且 s[i] == p[j];` 或者 `s[i] != p[j]` 那么`f[i][j] = false ` 

2. 如果 p的第 j个字符是 `*`，那么就表示我们可以对 p 的第 j-1 个字符匹配任意自然数次。在匹配 0 次的情况下，我们有
   匹配0次：`f[i][j] = f[i][j−2]` 且 `s[i] != p[j - 1]`

   匹配一次：`f[i][j] =f[i][j-2] 且 s[i] == p[j - 1]`

​	   匹配多次：`f[i][j] = f[i-1][j] 且 s[i] == p[j - 1]` （这种情况就是说明`f[i-1][j]`也是符合*匹配的，而且是至少匹配了一个。）		

3. 在任意情况下，只要 `p[j]` 是 `.`，那么 `p[j]` 一定成功匹配 s 中的任意一个小写字母。

   `f[i][j] = f[i - 1][j - 1]`

   综上可以分为：`p[j] = '*'`或者 `p[j] != '*'`这两种情况来处理。

   时间复杂度O(mn)

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(),n = p.length();
        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
      // 为啥i从0开始，而j从1开始？因为f数组中i j代表的是第几个字符，所以真实字符是从1开始，但是动态规划过程 
      // 匹配* 需要依赖到f[i -1][j]，比如i为1时，这样如果i从0开始，f[i -1][j]就得不到f[0][j]这个一维数组的正确答案
        for(int i = 0;i <= m;i++){
            for(int j = 1;j <= n;j++){
                if(p.charAt(j -1) == '*'){
                    // 先看*前面的字符是否匹配
                    f[i][j] = f[i][j -2];
                    // 看*前面的字符是否相同
                    if(matches(s,p,i,j -1)){
                        // 如果*前面的字符相同，可以匹配上一个字符，或者s中第i个字符匹配后，再看s中i-1个字符是否匹配
                        f[i][j] = f[i][j] || f[i -1][j];
                    }
                } else{
                    // 如果p第j个字符不为*，那就看第p中第j个字符为 .,或者和s中第i个字符相同
                    if(matches(s,p,i,j)){
                        f[i][j] = f[i-1][j-1];
                    }
                }
            }
        }
        return f[m][n];
    }
    private boolean matches(String s, String p,int i,int j){
        // s中没有字符
        if(i == 0){
            return false;
        }
        if(p.charAt(j-1) == '.'){
            return true;
        }
        return p.charAt(j-1) == s.charAt(i - 1);
    }
}
```

### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

题解：无。初始化为 O(1)，其余操作为 O(|S|),S为输入字符串长度。

```java
class Trie {
    Trie[] nexts;
    boolean isEnd;

    public Trie() {
        nexts = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        if(word == null){
            return;
        }
        // 根节点
        Trie node = this;
        // 遍历单词字符
        for(int i = 0; i < word.length();i++){
            int index = word.charAt(i) - 'a';
            // 如果没有该单词分支，新建
            if(node.nexts[index] == null){
                node.nexts[index] = new Trie();
            }
            // 有单词
            node = node.nexts[index];
        }
        // 有单词以这个字符结尾
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    private Trie searchPrefix(String prefix) {
        if(prefix == null){
            return null;
        }
        Trie node = this;
        // 查询是否有该单词对应分支
        for(int i = 0; i < prefix.length();i++){
            int index = prefix.charAt(i) - 'a';
            // 如果没有该单词分支
            if(node.nexts[index] == null){
                return null;
            }
            node = node.nexts[index];
        }
        return node;
    }
}
```

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

题解：动态规划。用`dp[i]`来枚举最少需要多少个数表示整数i，然后假设我们枚举 `i` 到了数 `j`,那么还要枚举剩下的 i -j^2^,则

`dp[i] = MIN(dp[i - j * j]) + 1`,      dp[i - j * j] + 1：即 `j*j` 是一个完全平方数，而`dp[i - j * j]`是一些 i -j^2^的完全平方数一种组合，两个加起来才是表示的全部，这里先求出dp[i - j * j]的最小最组合数。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for(int i = 1; i <= n;i++){
            int minn = Integer.MAX_VALUE;
            for(int j = 1; j * j <= i;j++){
                minn = Math.min(minn,dp[i - j * j]);
            }
          	// dp[i - j * j]最小组合数 + j * j，这一个完全平方数的组合
            dp[i] = minn + 1;
        }
        return dp[n];
    }
}
```

### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

题解：快慢指针。参考《142. 环形链表 II》题的快慢指针题解。使用快慢指针fast、slow,都从头节点出发，如果链表中有环，则它们一定会在环中相遇。环外走了a距离，slow入环后呀又走了b与fast相遇（fast在环中走了n圈）。所以fast走过的距离*a*+*n*(*b*+*c*)+*b*=*a*+(*n*+1)*b*+nc。又因为fast走的距离是slow走的两倍。所以*a*+(*n*+1)*b*+nc=2(*a*+*b*)⟹*a*=*c*+(*n*−1)(*b*+*c*)  -->  a=c+(n-1)(b+c)*a*=*c*+(*n*−1)(*b*+*c*) .               所以从链表头部到入环点的距离 等于 相遇点到入环点再加上 n-1圈环长。即相遇后把快指针放到头节点 一次移动一位继续走，当快慢指针再次撞上即入环点。入环点其实也就是本题要找的重复数字。

**本题如何用快、慢指针如何使用？**

因为数组长度 n + 1,且数字都在[1,n]范围内。索引index和数字num有个映射关系，index -> num,但当 有重复的数字num1，则它们的映射关系：index1 -> num1,index2 -> num1，就是说两个index映射到同一个数字上了，如果我把重复数字nums1当作index索引，就会遇到

index1 -> num1 -> ...... -> num2,index2 -> num1 -> ...... -> num2,而且这题完全可以这么做，因为题目给的数字大于0，所以不存在0是那个重复数字的可能，也就不存在两个0的索引指向同一个数字，所以这样就相当于入环前有一个0数字，从而保证一定会有入环点。这样就可以作为快指针，即：拿索引找到值，然后这个值作为下一步的索引，即slow = nums[slow]; 快指针则走了两步，通过索引拿到了值，再去把这个值作为索引去拿值，拿到的值作为下一步的索引，即：fast  = nums[nums[fast]]

![142_fig1](algorithm/142_fig1.png)

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        do {
            // 为啥用do while，因为，要保证0是入环外的索引
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);
        // 相遇后，慢指针放到头从0开始，快指针一步走一位，会在入环点相遇
       slow = 0;
       while(slow != fast){
           slow = nums[slow];
           fast = nums[fast];
       }
        return slow;
    }
}
```

### [301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

题解：回溯+ 剪枝。首先计算字符串s最少需要去掉的左括号数目lremove和右括号的数据rremove，然后在字符串s中去掉lremove个左括号和rremove个右括号，然后检测剩余的字符串是否合法，如果合法该字符串为可能的结果。时间复杂度O(n×2^n^)，空间复杂度：O(n^2^)。

1. 我们从字符串中每去掉一个括号，则更新 lremove 或者 rremove，当我们发现剩余未尝试的字符串的长度小于 lremove+rremove 时，则停止本次搜索。
2. 当 lremove 和 rremove 同时为 0 时，则我们检测当前的字符串是否合法匹配，如果合法匹配则我们将其记录下来。

3. 字符串可能会重复，去重。我们在每次进行搜索时，如果遇到连续相同的括号我们只需要搜索一次即可。

```java
class Solution {
    List<String> ans = new ArrayList<String>();
    public List<String> removeInvalidParentheses(String s) {
        int lremove = 0 ,rremove = 0;
        // 计算lremove rremove
        for(int i = 0; i < s.length();i++){
            if(s.charAt(i) == '('){
                lremove++;
            } else if(s.charAt(i) == ')'){
                if(lremove == 0){
                    rremove++;
                } else{
                    lremove--;
                }
            }
        }       
        help(s,0,0,0,lremove,rremove);
        return ans;
    }

    private void help(String s,int start,int lcount,int rcount,int lremove,int rremove){
        // 校验剩余字符串是否合法
        if(lremove == 0 && rremove == 0){
            if(isValid(s)){
                ans.add(s);
            }
            return;
        }
        for(int i = start; i < s.length();i++){
            if(s.charAt(i) == '('){
                lcount++;
            } else if(s.charAt(i) == ')'){
                rcount++;
            }
            // 字符串去重
            if(i > start && s.charAt(i) == s.charAt(i -1)){
                // 多个相同的括号删除一个即可
                continue;
            }
            // 剩余字符串长度小于 lremove+rremove 停止搜索
            if(lremove + rremove > s.length() - i){
                return;
            }
            // 删除左括号
            if(lremove > 0 && s.charAt(i) == '('){
                help(s.substring(0,i)+s.substring(i+1),i,lcount - 1,rcount,lremove -1,rremove);
            }
            // 删除右括号
            if(rremove > 0 && s.charAt(i) == ')'){
                help(s.substring(0,i)+s.substring(i+1),i,lcount,rcount -1,lremove,rremove -1);
            }
            // 如果右边括号比左边括号多，则不括号不合法
            if(rcount > lcount){
                break;
            }
        }
        
    }

    private boolean isValid(String str){
         // 校验剩余字符串是否合法
         int cnt = 0;
         for(int i = 0; i < str.length();i++){
             if(str.charAt(i) == '('){
                 cnt++;
             } else if(str.charAt(i) == ')'){
                 cnt--;
                 if(cnt < 0){
                     return false;
                 }
             }
         }
         return cnt == 0;
    }
}
```

### [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

题解：动态规划。我们用 `dp[i]` 表示第 i 天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：

1. 当天持股(今天买入/今天没操作(昨天持股)) 累计最大收益.`dp[i][0]`,

   `dp[i][0] = Math.max(dp[i-1][1] - prices[i],dp[i -1][0]);`

2. 当天不持股且且非冻结期(昨天是冻结期/或者昨天不持股非冻结期)  `dp[i][1]`

   `dp[i][1] = Math.max(dp[i-1][2],dp[i-1][1]);`

3. 当天不持股且冻结期(当天卖出的) `dp[i][2]`

   `dp[i][2] = dp[i -1][0] + prices[i];`

   很明显第 n-1天结束后，不持有股票收益最大，所以最大收益：`max(dp[i][1],dp[i][2])`

   为了减少空间复杂度，`dp[i][0] 、dp[i][1] 、dp[i][1]` 这个二维数组，用三个变量dp0、dp1、dp2代替。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0){
            return 0;
        }
        int n = prices.length;
        int dp0 = -prices[0];
        int dp1 = 0;
        int dp2 = 0;
        for(int i = 1;i < n;i++){
            int temp0 = dp0,temp1 = dp1,temp2 = dp2;
            // 当天持股(今天买入/今天没操作(昨天持股)) 累计最大收益
            dp0 = Math.max(temp1 - prices[i],temp0);
            // 当天不持股且且非冻结期(昨天是冻结期/或者昨天不持股非冻结期) 累计最大收益
            dp1 = Math.max(temp2,temp1);
            // 当天不持股且冻结期(当天卖出的) 累计最大收益
            dp2 = temp0 + prices[i];
        }
        return Math.max(dp1,dp2);
    }
}
```

### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

题解：动态规划。对于一个根节点来说可以被选中也可以不被选中，用数组`int[] dp = int[]{selected,notSelected}`表示每一个子树的根节点被选中的最大值`dp[0]`和不被选中的最大值`dp[1]`。

当前根结点selected时，它的左右子节点不能被选中，则：

`selectedVal = leftdp[notSelected] + rightedp[notSelected];` 

当前根结点notSelected时，它的左右节点可以被选中，也可以不被选中，则：

`notSelectedVal = max( leftdp[selected] ,leftdp[notSelected]) +  max( rightedp[selected] ,rightedp[notSelected])`

```java
class Solution {
    public int rob(TreeNode root) {
        if(root == null){
            return 0;
        }
        int[] countRoot = dfs(root);
        return Math.max(countRoot[0],countRoot[1]);
    }

    private int[] dfs(TreeNode root){
        if(root == null){
            return new int[]{0,0};
        }
        int[] l = dfs(root.left);
        int[] r = dfs(root.right);
        int selected = root.val + l[1] + r[1];
        int notSelected = Math.max(l[0],l[1]) + Math.max(r[0],r[1]);
        return new int[]{selected,notSelected};
    }
}
```

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

题解：小根堆。先遍历数组，把数字num当作key,出现次数当作value，放入map中，从而构建一个num : 出现次数的map。然后找出出现频率前k高的的数（map中value最大到....第k大的的对应key）。我们可以把key：value键值对组成一个数组放到小根堆heap中（根据出现次数排序大小），放入的时候：

1. 如果heap.size() < k (还不到k个)，那么直接放入堆中。

2. 如果heap.size() == k，则需要比较堆顶元素出现次数和当前元素出现次数，如果堆顶元素出现次数 > 当前元素出现次数 ，丢弃当前元素（说明当前元素不满足出现前k频率）；否则，弹出堆顶元素，把当前元素放入堆顶。

把堆中对应的数字取出，即为答案。时间复杂度：O(Nlogk)，空间复杂度：O(N)。

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int num : nums){
            map.put(num,map.getOrDefault(num,0) + 1);
        }
        // 小根堆
        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] m,int[] n){
                return m[1] - n[1];
            }
        }); 
        Set<Map.Entry<Integer,Integer>> entries = map.entrySet();
        for(Map.Entry<Integer,Integer>  entry : entries ){
            int num = entry.getKey(),count = entry.getValue();
            if(heap.size() == k){
                // 堆顶数字出现次数小于当前数字出现次数，丢弃堆顶数字
                if(heap.peek()[1] < count){
                    heap.poll();
                    heap.offer(new int[]{num,count});
                }
            } else {
                // 如果还没有满足k
                heap.offer(new int[]{num,count});
            }
        }
        int[] ans = new int[k];
        for(int i = 0;i < k;i++){
            ans[i] = heap.poll()[0];
        }
        return ans;
    }
}
```

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

题解：单调栈。用一个栈来储存数组对应的索引。	当栈不为空，且当前`(当前索引i)`对应的温度高于栈顶中储存的索引（preIndex）对应的温度时，弹出栈顶索引，意即：离栈顶中索引`(preIndex)`最近的温度比它高的温度`(当前索引i对应的温度)`出现（遍历到的当前温度），则把栈顶对应的索引`(preIndex)`弹出，i - preIndex 也就是 preIndex对应的 后面多少天后温度才会有更高。时间复杂度O(n).

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        if(temperatures.length == 0){
            return new int[0];
        }
        int n = temperatures.length;
        int[] ans = new int[n];
        LinkedList<Integer> stack = new LinkedList<Integer>();
        for(int i = 0;i < n ;i++){
            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]){
                int preIndex = stack.poll();
                ans[preIndex] = i - preIndex;
            }  
            stack.push(i);
        }
        return ans;
    }
}
```

### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

题解：1.动态规划。用`boolean dp[l][r]` 表示从i到j是否是回文，初始状态：l = r ,`dp[l][r] = true`。

当字符串长度不超过3时，左边字符和右边字符相等时即为回文；s.charAt(left) == s.charAt(right) &&  right - left < 3 

当字符长度超过3时，最左边和最右边的字符相同时，则需要判断相邻内部是否为回文，如果是，则当前字符串也是回文字符串即：

`s.charAt(left) == s.charAt(right) && dp[l + 1][r -1]`

```java
class Solution {
    public int countSubstrings(String s) {
        if(s.length() < 2){
            return s.length();
        }
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int count = 0;
        for(int right = 0;right < n;right++){
            for(int left = 0; left <= right;left++){
                if(s.charAt(left) == s.charAt(right) && (right - left < 3 || dp[left + 1][right -1])){
                    dp[left][right] = true;
                    count++;
                }
            }
        }
        return count;
    }
}
```

2.Manacher 算法。Manacher 算法是在线性时间内求解最长回文子串的算法。在所有的相邻字符中间插入 #，解决奇数长度和偶数长度的问题，假设原字符串为 S，经过这个处理之后的字符串为 s。

用 `f(i)`来表示以 s 的第 i 位为回文中心，可以拓展出的最大回文半径，那么 f(i) - 1 就是以 i 为中心的最大回文串长度 。

需要枚举 s 的每一个位置并先假设它是回文中心，利用已经计算出来的状态来更新 f(i)，假设我们已经计算好了 `[1, i - 1]` 区间内所有点的 f（即我们知道 `[1, i - 1]` 这些点作为回文中心时候的最大半径）， 那么我们也就知道了 `[1, i - 1]` 拓展出的回文达到最大半径时的回文右端点。知道 i 对应的f,那么很容易知道它的又端点 i + f(i) -1.

通过已经计算出来的状态更新`f(i)`,维护「当前最大的回文的右端点 r~m~」以及这个回文右端点对应的回文中心 i~m~。	顺序遍历 s，假设当前遍历的下标为 i 。我们知道在求解 f(i) 之前我们应当已经得到了从 `[1, i - 1]` 所有的 f，并且当前已经有了一个最大回文右端点 r~m~，以及它对应的回文中心 i~m~。

初始化`f(i)`:

​		如果 i <= r~m~，说明 i 被包含在当前最大回文子串内，假设 j 是 i 关于这个最大回文的回文中心 i~m~的对称位置（即 j + i = 2 * i~m~）,这里我们可以得到`f(i)`,至少等于min{ f( i ) , r~m~ - i + 1},这里将 f( i ) 和 r~m~ - i + 1取小，是先要保证这个回文串在当前最大回文串内。

​		如果 i > r~m~，那就先初始化 f( i ) = 1;

中心扩展：

​		做完初始化后，可以保证此时`s[i + f(i) − 1] = s[i − f(i) + 1]`,要继续拓展这个区域，就要继续判断`s[i + f(i)]` 和 `s[i - f(i)]` 是否相等，如果相等将f( i )自增；这样一直循环到`s[i + f(i)] != s[i - f(i)]`；以此类推，这样循环每次结束时，都能保证

`s[i + f(i) − 1] = s[i − f(i) + 1]`,而循环继续的条件一定是`s[i + f(i)] = s[i - f(i)]`,这时候为了不让索引越界，开头加一个$,结尾加一个!,这样开头和结尾一定不想等，循环在这里终结。

这样我们可以得到 s 所有点为中心的最大回文半径，也就能够得到 S 中所有可能的回文中心的的最大回文半径，把它们累加就可以得到答案。

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        // 开头添加一个$ 结尾添加一个!,中间每个字符间添加# 避免奇偶长度问题
        StringBuilder str = new StringBuilder("$#");
        for(int i = 0 ; i < n;i++){
            str.append(s.charAt(i));
            str.append("#");
        }
        n = str.length();
        // 防止越界 同时开头和结尾一定不相同
        str.append("!");
        int[] f = new int[n];
        int iMax = 0,rMax = 0,ans =0;
        for(int i = 1; i< n;i++){
            // 初始化f[i]
            f[i] = i<= iMax ? Math.min(rMax - i + 1,f[2 * iMax -i]) : 1;
            // 中心扩展
            while(str.charAt(i + f[i]) == str.charAt(i - f[i])){
                f[i]++;
            }
            // 动态维护 iMax rMax
            if(i + f[i] -1 > rMax){
                iMax = i;
                rMax = i + f[i] -1;
            }
            // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整
            ans+= f[i] / 2;
        }
        return ans;
    }
}
```

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

题解：动态规划。本题转化为从数组nums中取出子集使得子集的和等于 nums数组和的一半。动态规划前判断：数组长度是否可以被分割，长度小于2，返回false。计算整个数组元素和sum以及最大元素maxNum，如果sum为奇数，则不可能将数组分割成和相等的两个子集；如果是sum是偶数，则令target = sum/2,如果 maxNum > target，则除了target 以外的所有元素和一定小于target，返回false。

创建二维数组 dp，包含 n 行 target+1 列，其中 `dp[i][j]` 表示从数组的 `[0,i]` 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。

边界：不选取任何正整数，即选取的正整数都为0，所有对于所有 0 <= i < n，都有`dp[i][0] = true`;当 i == 0时，只有一个正整数 `nums[0]`可以被选取，所以`dp[0][nums[0]] = true`.

i > 0 且j > 0时：

​		`j >= nums[i]`，对于当前数字nums[i]，可以选取也可以不选取，只要有一个为true，就有`dp[i][j] = true`。

​			若不选取`nums[i]`，`dp[i][j] = dp[i -1][j]`;

​			若选取  `nums[i]`，`dp[i][j] = dp[i -1][j - nums[i]]`;

​		`j < nums[i]`，在选取数字和等于 j 的情况下，无法选取 `nums[i]`,所以 `dp[i][j] = dp[i -1][j]`.

时间复杂度`O(n * target)`，空间复杂度 `O(n * target)`

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums.length < 2){
            return false;
        }
        int sum = 0,maxNum = 0,n = nums.length;
        for(int num : nums){
            sum+=num;
            maxNum = Math.max(maxNum,num);
        }
        if(sum % 2 != 0){
            return false;
        }
        int target = sum / 2;
        if(maxNum > target){
            return false;
        }
        boolean[][] dp = new boolean[n][target + 1];
        for(int i = 0;i < n;i++){
            dp[i][0] = true;
        }
        dp[0][nums[0]] = true;
        for(int i = 1;i < n;i++){
            int num = nums[i];
            for(int j = 1; j<= target;j++){
                if(j >= num){
                    dp[i][j] = dp[i -1][j] || dp[i -1][j -num];
                } else {
                    dp[i][j] = dp[i -1][j];
                }
            }
        }
        return dp[n -1][target];
    }
}
```

发现在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：`dp[j] = dp[j] ∣ dp[j−nums[i]]`。**且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 `dp[j]` 值的时候，`dp[j−nums[i]]` 已经是被更新过的状态，不再是上一行的 dp 值**。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums.length < 2){
            return false;
        }
        int sum = 0,n = nums.length;
        for(int num : nums){
            sum+=num;
        }
        if(sum % 2 != 0){
            return false;
        }
        int target = sum / 2;
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;
        for(int i = 1;i < n;i++){
            int num = nums[i];
            // 这里最大的数字大于 target时一定不能进入循环，所以会返回false
            for(int j = target; j >= num;j--){
                dp[j] = dp[j] || dp[j -num];
            }
        }
        return dp[target];
    }
}
```

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

题解：前缀和。前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上`除当前节点以外所有节点的前缀和`，在`已保存的路径前缀和`中查找是否`存在前缀和`刚好等于当前节点到根节点的前缀和 curr 减去 targetSum。

对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 0。

假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为root→p~1~→p~2~ →…→p~k~→node，此时我们可以已经保存了节点 p~1~,p~2~,p~3~,…,p~k~的前缀和，并且计算出了节点 node 的前缀和。

假设当前从根节点 root 到节点 node 的前缀和为 curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 `curr−targetSum`。假设从根节点root 到节点 node 的路径中存在节点 p~i~ 到根节点 root 的前缀和为 curr−targetSum，则节点 p~i+1~到 node 的路径上所有节点的和一定为 targetSum。

我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long,Integer> prefix = new HashMap<>();
        // 前缀和为0
        prefix.put(0L,1);
        return dfs(root,targetSum,prefix,0);
    }

    private int dfs(TreeNode root, int targetSum,Map<Long,Integer> prefix,long curr){
        if(root == null){
            return 0;
        }
        int ret = 0;
        // 前缀和
        curr+=root.val;
        // 前缀和 = root到当前节点的前缀和 - targetSum,即存在targetSum
        ret = prefix.getOrDefault(curr - targetSum,0);
        // 更新前缀和curr对应的路径
        prefix.put(curr,prefix.getOrDefault(curr,0) + 1);
        // 更新左右子树上的 存在路径和为targetSum的个数
        ret+=dfs(root.left,targetSum,prefix,curr);
        ret+=dfs(root.right,targetSum,prefix,curr);
        // 回溯curr的路径
        prefix.put(curr,prefix.getOrDefault(curr,0) - 1);
        return ret;
    }
}
```

### [494. 目标和](https://leetcode.cn/problems/target-sum/)

题解：动态规划。可以先参考《416. 分割等和子集》，都是背包问题。记数组的元素和为 sum，添加 - 号的元素之和为 neg，则其余添加 + 的元素之和为 sum−neg，得到的表达式的结果为 `(sum−neg)−neg=sum−2⋅neg=target`即 `neg = (sum−target) / 2`

由于数组 nums 中的元素都是非负整数，neg 也必须是非负整数，所以上式成立的前提是 sum−target 是非负偶数。若不符合该条件可直接返回 0。

若上式成立，问题转化成在数组 nums 中选取若干元素，使得这些元素之和等于 neg，计算选取元素的方案数。用动态规划方法求解。

定义二维数组 dp，其中 `dp[i][j]` 表示在数组 nums 的前 i 个数中选取元素，使得这些元素之和等于 j 的方案数。假设数组 nums 的长度为 n，则最终答案为 `dp[n][neg]`。

当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：`j = 0时，dp[0][j] = 1；j >=1时，dp[0][j] = 0`.

当 `1 ≤ i≤ n` 时，对于数组 nums 中的第 i 个元素 num（i 的计数从 1 开始），遍历 `0≤j≤neg`，计算 `dp[i][j]` 的值：

如果 `j<num`，则不能选 num，此时有 `dp[i][j]=dp[i−1][j]`；

如果 `j≥num`，则如果不选 num，方案数是 `dp[i−1][j]`，如果选 num，方案数是 `dp[i−1][j−num]`，此时有 

`dp[i][j]=dp[i−1][j]+dp[i−1][j−num]`。

最终得到 `dp[n][neg]` 的值即为答案。时间复杂度：`O(n * (sum − target))`，空间复杂度为 `O(n * neg)` 。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for(int num : nums){
            sum+=num;
        }
        int diff = sum -target;
        if(diff < 0 || diff % 2 != 0){
            return 0;
        }
        int n = nums.length,neg = diff / 2;
        int[][] dp = new int[n + 1][neg +1];
        dp[0][0] = 1;
        for(int i = 1;i <= n;i++){
            int num = nums[i -1];
            for(int j = 0;j <= neg;j++){
                dp[i][j] = dp[i - 1][j];
                if(j >= num){
                    dp[i][j]+= dp[i -1][j -num];
                }
            }
        }
        return dp[n][neg];
    }
}
```

空间复杂度优化：dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度优化到 `O(neg)`即O(sum -target)。实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 `dp[i−1][]` 中的元素值。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for(int num : nums){
            sum+=num;
        }
        int diff = sum -target;
        if(diff < 0 || diff % 2 != 0){
            return 0;
        }
        int n = nums.length,neg = diff / 2;
        int[] dp = new int[neg +1];
        dp[0]= 1;
        for(int i = 1;i <= n;i++){
            int num = nums[i -1];
            for(int j = neg;j >= num;j--){
                dp[j] += dp[j -num];
            }
        }
        return dp[neg];
    }  
}
```

### [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

题解：一次遍历。我们把原数组分割为nums~A~,nums~B~,nums~C~,其中nums~B~是我们要找的数组区间，其实会发现nums~B~,nums~C~中的最小值都比nums~A~中的最大值大。从大到小枚举 i，`nums[i] <= minNum`,等式满足时更新minNum，最后一个使得不等式成立的 i 即为nums~B~的左边界，记start = i；nums~B~的右边界同理，nums~A~,nums~B~,中的最大值都比nums~C~的最小值小，从小到大枚举i，`nums[i] >= maxNum`,等式满足时候maxNum，最后一个使得不等式成立的 i 即为nums~B~的右边界，记end = i。

时间复杂度O(N)，空间复杂度O(1).

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int start = -1,end = -1;
        int minNum = Integer.MAX_VALUE;
        int maxNum = Integer.MIN_VALUE;
        for(int i = 0; i < n;i++){
            // 数组最大值从左往右更新，这样才能找到要找的数组区间最右
           if(nums[i] < maxNum){
               end = i;
           } else {
               maxNum = nums[i];
           }
            // 数组的最小值从右往左更新，找到数组区间最左
           if(nums[n - i -1] > minNum){
               start = n -i -1;
           } else {
               minNum = nums[n -i -1];
           }
        }
        return end == -1 ? 0 : end - start + 1;
    }
}
```

### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

题解：由二叉搜索树性质发现，二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值。

```java
class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if(root != null){
            convertBST(root.right);
            sum+= root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
}
```

### [461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

题解：1.异或+向右位移。先异或出两数中的不相等位的1，然后不停的向右位移，每遇到一个1，则答案++。

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int z = x ^ y,ans = 0;
        while (z != 0) {
            ans += z & 1;
            z >>= 1;
        }
        return ans;
    }
}
```

2.Brian Kernighan 算法。记 f(x) 表示 x 和 x−1 进行与运算所得的结果（即 f(x)=x & (x-1)），那么 f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。这样代替方法1的位移 + 和1与运算统计1的个数。

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int z = x ^ y,ans = 0;
        while (z != 0) {
            z &=z-1;
            ans++;
        }
        return ans;
    }
}
```

### [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

题解：在原数组上修改。可以用一个hash表来记录出现在nums中的数字，数字范围均在 [1,n] 中，记录数字后我们再利用哈希表检查 [1,n] 中的每一个数是否出现，从而找到缺失的数字。

由于不然用额外空间，可以用一个长度为 n 的数组来代替哈希表。nums长度为n,数字范围[1,n] ，利用范围外的数字来判断数组是否存在。具体来说：（其实就是让数字映射到数组索引位置，然后改变对应位置的值为+n,没有影射到的位置，说明没有这个数字（`数字[1,n] 数字减1对应索引-> 索引 [0,n-1]`））遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 [1,n] 中，增加以后，这些数必然大于 n。最后我们遍历 nums，若 `nums[i]` 未大于 n，就说明没有遇到过数i+1。这样我们就找到了缺失的数字。

注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值。

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for(int x :nums){
            // nums[x -1]位置可能被加过n多次，所以需要对n取模，找回原数字
            x = (x- 1) % n;
            nums[x]+=n;
        }
        List<Integer> ans = new ArrayList<>();
        for(int i = 0;i < n;i++){
            if(nums[i] <= n){
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

题解：滑动窗口。当s长度小于p长度时，这种情况是不存在异位词的，直接返回。在字符串s中构建一个长度为p字符串长度的滑动窗口，每当窗口中子字符串的字母和p字母相同时，记录下窗口子字符串的开始位置。窗口子字符串和p字符串相同：这里用长度为26的数组代替hash表，就是每出现一个字母，就在数组中字母对应的映射位++；然后比较两个数组是否相等。窗口每次移动的时候修改窗口的应的数组。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(),pLen = p.length();
        if(sLen < pLen){
            return new ArrayList<Integer>();
        }
        // 用长度为26的数组代替hash表来表示相同字符组成的字符串
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        for(int i = 0;i < pLen;i++){
            sCount[s.charAt(i) - 'a']++;
            pCount[p.charAt(i) - 'a']++;
        }
        ArrayList<Integer> ans = new ArrayList<Integer>();
        if(Arrays.equals(sCount,pCount)){
            ans.add(0);
        }
        // 从索引 pLen继续往后滑动
        for(int i = 0;i < sLen -pLen;i++){
            sCount[s.charAt(i) - 'a']--;
            sCount[s.charAt(i + pLen) - 'a']++;
            if(Arrays.equals(sCount,pCount)){
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
```

滑动窗口优化。我们不再分别统计滑动窗口和字符串 p 中每种字母的数量，而是统计滑动窗口和字符串 p 中每种字母数量的差；并引入变量 differ 来记录当前窗口与字符串 p 中数量不同的字母的个数，并在滑动窗口的过程中维护它。

在判断滑动窗口中每种字母的数量与字符串 p 中每种字母的数量是否相同时，只需要判断 differ 是否为零即可。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(),pLen = p.length();
        if(sLen < pLen){
            return new ArrayList<Integer>();
        }
        // 用长度为26的数组代替hash表来表示相同字符组成的字符串
        int[] count = new int[26];
        for(int i = 0;i < pLen;i++){
            count[s.charAt(i) - 'a']++;
            count[p.charAt(i) - 'a']--;
        }
        ArrayList<Integer> ans = new ArrayList<Integer>();
        int diff = 0;
        for(int i = 0;i < 26;i++){
            if(count[i] != 0){
                diff++;
            }
        }
        if(diff == 0){
            ans.add(0);
        }

        // 从索引 pLen继续往后滑动
        for(int i = 0;i < sLen -pLen;i++){
            // 窗口左边从i滑出
            if(count[s.charAt(i) - 'a'] == 1){
                // 从不相同变成相同（因为窗口右移，这个字符被舍弃）
                diff--;
            } else if(count[s.charAt(i) - 'a'] == 0){
                // 从相同变得不同，原来都有的字符，因为窗口右移，使得窗口少了该字符
                diff++;
            }
            count[s.charAt(i) - 'a']--;
            // 窗口右边从i + pLen滑入
            if(count[s.charAt(i + pLen) - 'a'] == -1){
                // 从不相同变成相同（因为窗口右移，这个增加该字符）
                diff--;
            } else if(count[s.charAt(i + pLen) - 'a'] == 0){
                // 从相同变得不同，原来都没有的字符，因为窗口右移，使得窗口多了该字符
                diff++;
            }
            count[s.charAt(i + pLen) - 'a']++;
            if(diff == 0){
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
```

### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

题解：将每个人按照身高从大到小进行排序，处理身高相同的人使用的方法类似，即：按照 h~i~为第一关键字降序，k~i~为第二关键字升序进行排序。如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第 i 个人时：

第 0, ⋯,i−1 个人已经在队列中被安排了位置，他们只要站在第 i 个人的前面，就会对第 i 个人产生影响，因为他们都比第 i 个人高；

而第 i+1,⋯,n−1 个人还没有被放入队列中，并且他们无论站在哪里，对第 i 个人都没有任何影响，因为他们都比第 i 个人矮。

在这种情况下，我们无从得知应该给后面的人安排多少个「空」位置。但我们可以发现，后面的人既然不会对第 i 个人造成影响，我们可以采用「插空」的方法，依次给每一个人在当前的队列中选择一个插入的位置。也就是说，当我们放入第 i 个人时，只需要将其插入队列中，使得他的前面恰好有 k~i~个人即可。 时间复杂度O(N^2^)，空间复杂度：O(log n).

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 按身高hi降序 ,ki升序
        Arrays.sort(people,new Comparator<int[]>(){
            public int compare(int[] people1,int[] people2){
                if(people1[0] != people2[0]){
                    return people2[0] -people1[0];
                } else{
                    return people1[1] - people2[1];
                }
            }
        });
        ArrayList<int[]> ans =new ArrayList<int[]>();
        for(int[] person : people){
            // 放入第i个人，是的他前面刚好有ki个人
            ans.add(person[1],person);
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

### [312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

题解：动态规划。给原数组两端加 -1 和 n 防止越界，变成新数组val。观察戳气球的操作，发现这会导致两个气球从不相邻变成相邻，使得后续操作难以处理。于是我们倒过来看这些操作，将全过程看作是每次添加一个气球。自底向上，令 `dp[i][j]` 表示填满开区间 `(i,j)` 能得到的最多硬币数，那么边界条件是 `i ≥ j−1`，此时有 `dp[i][j]=0`。

`i < j−1`时，`dp[i][j] = (val[i] * val[mid] * val[j] + dp[i][mid] + dp[mid][j])所有的和中取最大值`,

最终答案`dp[0][n + 1]`.时间复杂度 O(n^3^)，空间复杂度 O(n^2^).

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n+2][n+2];
        int[] val = new int[n+2];
        // 给原数组两端加 -1 和 n 防止越界
        val[0] = val[n+1] = 1;
        for(int i = 1; i<= n;i++){
            val[i] = nums[i-1];
        }
        for(int i = n -1;i >= 0;i--){
           for(int j = i + 2;j <= n + 1;j++){
               for(int mid = i + 1; mid < j;mid++){
                   int sum = val[i] * val[mid] * val[j];
                   sum += dp[i][mid] + dp[mid][j];
                   dp[i][j] = Math.max(dp[i][j],sum);
               }
           }
        }
        return dp[0][n + 1];
    }
}
```

### [621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

题解：构造。见官方题解2:https://leetcode.cn/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        Map<Character,Integer> freq = new HashMap<>();
        // 获取执行次数最大的任务
        int maxExec = 0;
        for(char task : tasks){
            int exec = freq.getOrDefault(task,0) + 1;
            freq.put(task,exec);
            maxExec = Math.max(maxExec,exec);
        }
        // 获取执行次数最大的任务种类
        int maxExecCount = 0;
        for (Map.Entry<Character, Integer> execFreq : freq.entrySet()) {
            int value = execFreq.getValue();
            if (maxExec == value) {
                maxExecCount++;
            }
        }
        return Math.max((maxExec - 1) * (n + 1) + maxExecCount, tasks.length);
    }
}
```

### [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

题解：并查集。见官方题解：https://leetcode.cn/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/。

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int equationsSize = equations.size();
        UnionFind unionFind = new UnionFind(2 * equationsSize);
        // 1 解析已知条件到并查集，将变量值与id绑定，方便利用数组实现的并查集
        Map<String,Integer> map = new HashMap<>(2 * equationsSize);
        int id = 0;
        for(int i = 0;i < equationsSize;i++){
            List<String> equation = equations.get(i);
            String var1 = equation.get(0);
            String var2 = equation.get(1);
            if(!map.containsKey(var1)){
                map.put(var1,id);
                id++;
            }
            if(!map.containsKey(var2)){
                map.put(var2,id);
                id++;
            }
            unionFind.union(map.get(var1),map.get(var2),values[i]);
        }
        // 查询
        int n = queries.size();
        double[] ans = new double[n];
        for(int i = 0;i < n; i++){
            List<String> query = queries.get(i);
            Integer id1 = map.get(query.get(0));
            Integer id2 = map.get(query.get(1));
            if(id1 == null || id2 == null){
                ans[i] =  -1.0d;
            } else {
                ans[i] = unionFind.isConnected(id1,id2);
            }
        }
        return ans;
    }

    private class UnionFind{
        private int[] parent;
        // 指向父节点的权值
        private double[] weight;

        public UnionFind(int n){
            this.parent = new int[n];
            this.weight = new double[n];
            // 设置id 和权值关系
            for(int i = 0; i< n;i++){
                parent[i] = i;
                weight[i] = 1.0d;
            }
        }
        // 并查集合并
        public void union(int x,int y,double value){
            int rootX = find(x);
            int rootY = find(y);
            // 有共同根节点直接返回,不需要再合并
            if(rootX == rootY){
                return;
            }
            parent[rootX] = rootY;
            weight[rootX] = weight[y] * value / weight[x];

        }
        // 压缩路径
        public int find(int x){
            // 把节点连到最顶层节点下
            if(x != parent[x]){
                int origin = parent[x];
                parent[x] = find(parent[x]);
                weight[x] *= weight[origin];
            }
            return parent[x];
        }
        // 判断两个节点是否在有一个共同的根结点，并返回指向根节点的权值，如果没有共同根节点返回 -0.1
        public double isConnected(int x,int y){
            int rootX = find(x);
            int rootY = find(y);
            if(rootX == rootY){
                return weight[x] / weight[y];
            } else {
                return -1.0d;
            }
        }
    }
}
```



